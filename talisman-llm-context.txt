<TalisDemoApp path="/demo/web_client/index.html">
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="language" content="en" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" type="image/ico" href="favicon.ico" />
  	
<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" 
      integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" 
      crossorigin="anonymous" />

<!-- Optional theme -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" 
      integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" 
      crossorigin="anonymous" />
      
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet" />

<script src="bootstrap.js.php"></script>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>        
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" 
     integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" 
     crossorigin="anonymous"></script>
   	
		
<script src="https://unpkg.com/react@15/dist/react.js"></script>
<script src="https://unpkg.com/react-dom@15/dist/react-dom.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js"></script>


<link href="local.css" rel="stylesheet" />

<title>REACT based Demo for TalisMS</title>

<script>
function call_server(url,params,bind){
	$.ajax({
          url: url,
          dataType: 'json',
          data: params,
          cache: false,
          success: function(data) {
            bind.setState({server_response: data.toSource()});
          }.bind(bind),
          error: function(xhr, status, err) {
          	let response = $.parseJSON(xhr.responseText);
          	bind.setState({server_response: 'ERROR: ' + err.toString() + ' [' + response.message + '] Check your server logs'});
          }.bind(bind)
        });
}

</script>

<script type="text/babel">
function PageTitle(props){
	var style = {
      color: 'white',
      backgroundColor:'#202d1f'
    };
	return (
		<div className="row" style={style}><h1 className="col-lg-4 col-lg-offset-4">REACT Based TalisMS demo</h1></div>
	);
}

function Title(props){
    return <h3 className="col-lg-4 col-lg-offset-4">{props.title}</h3>;
}

function GETParamInp (props){
	return (
		<input className="get-param-inp" type="text" placeholder={props.label} value={props.value} onChange={ (event)=>props.onChange(event) } />
	);
}

function RunTestBtn(props){
	return(
		<input className="run-test-btn" type="button" value="run test" onClick={()=> props.onClick() }/>
	);
}

function TestResponsePanel(props){
	return (
		<div className="test-response-panel">{props.content}</div>
	);
}

class TestPanel extends React.Component{
	constructor(props) {
	    super(props);
	    this.state = {client_request:'', server_response: 'waiting for you to press the pink button on the left',get_params:''};
	    this.handleGetParamsChange = this.handleGetParamsChange.bind(this);
	}

	handleRunTest(){
		const url = window.base_url + this.props.url + this.state.get_params + '/';
		this.setState({client_request:  url});
		// Call server and see what we get back
		window.call_server(url,this.props.data,this);
	}

	handleGetParamsChange(event){
		this.setState({get_params: event.target.value});
	}

	render(){
		const style = {
	      backgroundColor: this.props.background
	    };
		return (
			<div className="row" style={style}>
	  		    <div className="row"><Title title={this.props.title} /></div>
			    <div className="row">
			    	<div className="col-lg-2 col-lg-offset-2">
						<GETParamInp label="Enter get params (optional) /f/v/f/v" value={this.state.get_params} onChange={ (event)=>this.handleGetParamsChange(event) } />
						<RunTestBtn onClick={ ()=>this.handleRunTest() }/>
					</div>
					<div className="col-lg-2 col-lg-offset-1">
						<TestResponsePanel content={this.state.client_request}/>
						<TestResponsePanel content={this.state.server_response}/>
					</div>
				</div>
			</div>
	    );
    }
}



function init(props){
    ReactDOM.render(<div className="container-fluid">
    					<PageTitle />
						<TestPanel title="Doing PING"         background="black"    url='/ping/read' data={{}} />
						<TestPanel title="Doing DEPENDENCIES" background="#506f4d"  url='/dependency/create' data={{}} />
                    </div>,
                    document.getElementById('root'));
}


init({});
</script>

</head>
<body>
<div id="root"></div><!-- EOF root -->
</body>
</html>
</TalisDemoApp>

<TalisDemoApp path="/demo/web_client/bootstrap.js.php">
<?php
function base_url(){
	switch(lifeCycle()){
		case 'itay_development':
			return 'http://192.168.12.148/talis/test';
	}
}
?>
var base_url = "<?=base_url()?>";
</TalisDemoApp>

<TalisDemoApp path="/demo/web_client/local.css">
@CHARSET "UTF-8";
.row{
	color: #111111;	
}

h3{
	color: white;
}

.get-param-inp{
	width: 400px;
	border-style: none;
}

.run-test-btn{
	background-color: #f94d86;
	width: 400px;
	height: 380px;
	border-style: none;
	font-size: 4em;
	margin-bottom: 20px;	
}

.test-response-panel{
	background-color: white;
	width: 400px;
	height: 200px;
}
</TalisDemoApp>

<TalisDemoApp path="/demo/cli_client/ping.php">



============================================================================ START TESTING ================================================================================






============================================================================== empty ping  ================================================================================
<?=`../../doors/cli/lord_commander /test/ping/read {}`?>


======================================================================= empty ping base64 encoded body ====================================================================

<?
$r = base64_encode('{}');
$cmd = "../../doors/cli/lord_commander /test/ping/read {$r} yes";
echo `$cmd`;
echo "\n";
?>

==============================================================================  ping  /v/1/f/2 {empty} ================================================================================
<?=`../../doors/cli/lord_commander /test/ping/read/v/1/f/2 {}`?>


======================================================================= ping base64 encoded body  /v/1/f/2 {empty} ====================================================================

<?
$r = base64_encode('{}');
$cmd = "../../doors/cli/lord_commander /test/ping/read/v/1/f/2 {$r} yes";
echo `$cmd`;
echo "\n";
?>


==============================================================================  ping  body{"momo_body":1,"fofo_body":2}  ================================================================================
<?=`../../doors/cli/lord_commander /test/ping/read {"momo_body":1,"fofo_body":2}`?>


======================================================================= ping base64 encoded body  body{"momot_body":1,"fofo_body":2}  ====================================================================

<?
$r = base64_encode('{"momot_body":1,"fofo_body":2}');
$cmd = "../../doors/cli/lord_commander /test/ping/read {$r} yes";
echo `$cmd`;
echo "\n";
?>



==============================================================================  ping error  ================================================================================
<?=`../../doors/cli/lord_commander /testus/pingus/read {"t":1,"f":2}`?>
</TalisDemoApp>

<TalisDemoApp path="/demo/rest_client/filters.php">
<?php
include 'bootstrap.php';
echo "\n\n================================== filter does nothing, missing the params (should fail)  ==================================\n";
$obj=new stdClass;
$obj->params=[];
get_client('/test/filter/read',$obj);

echo "\n\n================================== filter does nothing, has the params  ==================================\n";
$obj=new stdClass;
$obj->params=['shubi'=>'dubi'];
get_client('/test/filter/read',$obj);

echo "\n\n================================== filter has the field, but not the value to modify ->does nothing  ==================================\n";
$obj=new stdClass;
$obj->params=['mumble'=>'dubi'];
get_client('/test/filter/read',$obj);

echo "\n\n================================== filter has the field and the value -> modifies it to brumbrum  ==================================\n";
$obj=new stdClass;
$obj->params=['mumble'=>'blabla'];
get_client('/test/filter/read',$obj);

</TalisDemoApp>

<TalisDemoApp path="/demo/rest_client/bootstrap.php">
<?php
ini_set('error_reporting', E_ALL|E_STRICT);
ini_set('log_errors', true);
function autoload($class) {
	$file_path = str_replace(['_','\\'],'/',$class) . '.php';
	if(!include_once $file_path){
		throw new Exception("{$file_path} {$class}");
	}
}
spl_autoload_register('autoload');

function get_client(){
    //return Zend IHttpClient::factory($url . $uri);
}
/**
 * @param string $uri
 * @param stdClass $obj
 * @param string $https
 * @return mixed
 */
function get_client($uri,stdClass $obj,$https=false){
	$s = $https ? 's' : '';
	$urls = [ 
			'itay_development' => "http{$s}://192.168.12.148/talis",
			'newstaging' => "http{$s}://api.newstaging.sitelms.org/scheduler",
			'prod_web' => "http{$s}://api.web01.sitelms.org/scheduler" 
	];
	
	$url = $urls [lifeCycle ()];
	echo "hitting [{$url}{$uri}]\n";
	echo "SENDING THE FOLLOWING:\n";
	var_dump ( json_encode ( $obj ) );
	
	/**
	 * INIT A NEW INSTALLATION ACTIVATION
	 */
	// initiate POST
	$Client = get_client();
	
	// not relevant
	$Client->setRawBody(json_encode($obj));
	
	try {
		$response = $Client->send();
	} catch ( Exception $e ) {
		echo $e;
	}
	echo "\n\nRESPONSE IS:\n";
	printf ( "Return code is [%d %s]\n", $response->getStatusCode(),$response->getReasonPhrase());
	var_dump ( $response->getBody() );
	$Json = json_decode ( $response->getBody());
	return $Json;
}



/**
 * Wrapper for the Zend 1.x http class to add the getRequestHeaders()
 * This is for debug purposes
 *
 * @author Itay Moav
 */
/*TOBE RE IMPLEMENTED 
class Zen dIHttpClient extends \Zen d\Http\Client{
	static public function factory(string $url):ZendIHttpClient{
		$client = new ZendIHttpClient ( $url, array (
				'adapter' => 'Zend\Http\Client\Adapter\Curl',
				'sslverifypeer' => false,
				'maxredirects' => 1,
				'timeout' => 5,
				'useragent' => 'LMS_LiveAccess' 
		));
		$client->setMethod(\Ze nd\HTTP\Request::METHOD_POST);
		$client->setHeaders (['Content-type'=>'application/json'] );
		return $client;
	}
	
	private $my_headers = [ ];
	
	/**
	 * Capture the headers for debug purposes later
	 *
	 * @see \Zen d\Http\Client::prepareHeaders()
	 */
/*
	protected function prepareHeaders($body, $uri){
		$this->my_headers = parent::prepareHeaders($body, $uri);
		return $this->my_headers;
	}
	
	public function getRequestHeaders(){
		return $this->my_headers;
	}
	
	/**
	 * @return string GET|POST|PUT|DELETE
	 */
/*	public function getCurrentMethod(){
		return $this->getRequest()->getMethod();
	}
	
	/**
	 * @return string getter for the POST/PUT raw data
	 */
/*	public function getRawRequestData(){
		return $this->getRequest()->getContent();
	}
}
*/
</TalisDemoApp>

<TalisDemoApp path="/demo/rest_client/ping.php">
<?php
include 'bootstrap.php';
echo "\n\n================================== PING  ==================================\n";
$obj=new stdClass;
$obj->params=[];
get_client('/test/ping/read',$obj);


echo "\n\n================================== PING  /i/x/b/1/f/5 ==================================\n";
$obj=new stdClass;
$obj->params=[];
get_client('/test/ping/read/i/x/b/1/f/5',$obj);
</TalisDemoApp>

<TalisDemoApp path="/demo/rest_client/dependencies.php">
<?php
include 'bootstrap.php';
echo "\n\n================================== dependency fields baba & user exists  ==================================\n";
$obj=new stdClass;
$obj->params=[];
get_client('/test/dependency/create/user/121/baba/ganush',$obj);

echo "\n\n================================== dependency baba Missing & user exists ==================================\n";
$obj=new stdClass;
$obj->params=[];
get_client('/test/dependency/create/user/121',$obj);

echo "\n\n================================== dependency baba Misspelled & user exists ==================================\n";
$obj=new stdClass;
$obj->params=[];
get_client('/test/dependency/create/babka/23/user/121',$obj);

echo "\n\n================================== dependency baba & user missing ==================================\n";
$obj=new stdClass;
$obj->params=[];
get_client('/test/dependency/create',$obj);
</TalisDemoApp>

<TalisDemoApp path="/demo/daemon_client/bootstrap.php">
<?php
require_once __DIR__ . '/../../config/environment/'.lifeCycle().'.php';

ini_set('include_path', '.' .
		PATH_SEPARATOR . '/usr/share/php/TalisMS001'
);

function autoload($class) {
	$file_path = str_replace(['_','\\'],'/',$class) . '.php';
	include_once $file_path;
}

spl_autoload_register('autoload');

//Logger
\ZimLogger\MainZim::factory(
		'none important',
		'Stdio',
		4,
		'none important'
);

class talis extends \SiTEL\DataSources\ActiveMQ\Publisher{
    use \SiTEL\DataSources\ActiveMQ\tQueue;
}
</TalisDemoApp>

<TalisDemoApp path="/demo/daemon_client/ping.php">
the request looks (so u can copy paste and run manually in the ActiveMQ web console)
Anyway, to test this, u need to watch logs.

{"url":"/test/ping/read",
 "params":{}
}

{"url":"/test/ping/read/param/1",
 "params":{}
}


{"url":"/test/ping/read/more/params/where/added",
 "params":{}
}



============================================================================== START TESTING ====================================================================



<?php
require_once 'bootstrap.php';
$p = talis::get_client();

$dependency1 = "{\"url\":\"/test/ping/read\",\"params\":{}}";
$dependency2ing2 = "{\"url\":\"/test/ping/read/param/1\",\"params\":{}}";
$ping3 = "{\"url\":\"/test/ping/read/more/params/where/added\",\"params\":{}}";

$p->publish($dependency1);
$p->publish($dependency2ing2);
$p->publish($ping3);

</TalisDemoApp>

<TalisDemoApp path="/demo/daemon_client/dependencies.php">
the request looks (so u can copy paste and run manually in the ActiveMQ web console)
Anyway, to test this, u need to watch logs.


================================== dependency get fields baba & user exists  ==================================
{"url":"/1/test/dependency/create/user/121/baba/ganush",
 "params":{}
}


================================== dependency get fields baba Missing & user exists ==================================
{"url":"/1/test/dependency/create/user/121",
 "params":{}
}


================================== dependency baba Misspelled & user exists ==================================
{"url":"/1/test/dependency/create/babka/23/user/121",
 "params":{}
}


================================== dependency baba & user missing ==================================
{"url":"/1/test/dependency/create",
 "params":{}
}

============================================================================== START TESTING ====================================================================



<?php
require_once 'bootstrap.php';
$p = talis::get_client();

$dependency1 = "{\"url\":\"/1/test/dependency/create/user/121/baba/ganush\",\"params\":{}}";
$dependency2 = "{\"url\":\"/1/test/dependency/create/user/121\",\"params\":{}}";
$dependency3 = "{\"url\":\"/1/test/dependency/create/babka/23/user/121\",\"params\":{}}";
$dependency4 = "{\"url\":\"/1/test/dependency/create\",\"params\":{}}";


$p->publish($dependency1);
$p->publish($dependency2);
$p->publish($dependency3);
$p->publish($dependency4);


</TalisDemoApp>

<TalisDemoApp path="/config/bootstrap_example_with_logger.php">
<?php

//HEre you put constants and ini settings
require_once __DIR__ . '/config.php';


//HANDLE AUTOLOADING FOR CODE UNDER APPLICATION FOLDER
/**
 *
 * @return callable
 */
function getAutoloader(){
    /**
     * @param string $class
     * @throws \Talis\Exception\ClassNotFound
     */
    return function (string $class):void {
        $file_path = str_replace('\\','/',$class) . '.php';
        require_once $file_path;
    };
}

spl_autoload_register(getAutoloader(),true);


//COMPOSER
require_once __DIR__ . '/../vendor/autoload.php';

//Instantiate the logger. This just sets the main/defaul logger, u can use other instances throughout.
//U can overwrite this one too later on
\ZimLogger\MainZim::setGlobalLogger(
    'talisms_test',
    'Stdio',
    4,
    '/some/path/to/write/log',
    false
);

//Shortcut functions for usage of default logger dbg,dbgn,dbgr,info,warning,error,fatal
\ZimLogger\MainZim::include_shortcuts();

// necessary for including the API classes, for example (in TalisMain)
\Talis\TalisMain::$APP_PATH = APP_PATH;

//Sets the logger used inside Talis, if need a separate logger just for Talis lib errors, this is where u overwrite it
\Talis\TalisMain::set_logger(new ZimLoggerWrapper(\ZimLogger\MainZim::$GlobalLogger));

//TODO Move this to another bootstrap with an example
//\Talis\TalisMain::$registered_router = 'Some Router Class Name to override defaults'; 



class ZimLoggerWrapper implements \Talis\commons\iLogger{
    
    /**
     * 
     */
    public function __construct(private \ZimLogger\Handlers\aLogHandler $logger){

    }

    /**
     *
     * @param mixed $inp : The piece you want to send the log. Make sure it isa datatype your logger can handle
     */
    public function debug(mixed $inp):void{
        $this->logger->debug($inp);
    }
    
    /**
     *
     * @param mixed $inp : The piece you want to send the log. Make sure it isa datatype your logger can handle
     * @param bool $full_stack : A boolean flag to tell the logger (if it has this capability, otherwise just send false) to add
     *                           some default stuff to the log entry (can be trace, some stats, SESSION etc)
     */
    public function info(mixed $inp,bool $full_stack):void{
        $this->logger->debug($inp,$full_stack);
    }
    
    /**
     *
     * @param mixed $inp : The piece you want to send the log. Make sure it isa datatype your logger can handle
     * @param bool $full_stack : A boolean flag to tell the logger (if it has this capability, otherwise just send false) to add
     *                           some default stuff to the log entry (can be trace, some stats, SESSION etc)
     */
    public function warning(mixed $inp,bool $full_stack):void{
        $this->logger->debug($inp,$full_stack);
    }
    
    /**
     *
     * @param mixed $inp : The piece you want to send the log. Make sure it isa datatype your logger can handle
     * @param bool $full_stack : A boolean flag to tell the logger (if it has this capability, otherwise just send false) to add
     *                           some default stuff to the log entry (can be trace, some stats, SESSION etc)
     */
    public function error(mixed $inp,bool $full_stack):void{
        $this->logger->debug($inp,$full_stack);
    }
    
    /**
     *
     * @param mixed $inp : The piece you want to send the log. Make sure it isa datatype your logger can handle
     * @param bool $full_stack : A boolean flag to tell the logger (if it has this capability, otherwise just send false) to add
     *                           some default stuff to the log entry (can be trace, some stats, SESSION etc)
     */
    public function fatal(mixed $inp,bool $full_stack):void{
        $this->logger->debug($inp,$full_stack);
    }   
}
</TalisDemoApp>

<TalisDemoApp path="/config/bootstrap.php">
<?php 
require_once __DIR__ . '/bootstrap_example_with_logger.php';

</TalisDemoApp>

<TalisDemoApp path="/config/config.php">
<?php namespace init;
ini_set('error_reporting', E_ALL);
ini_set('log_errors',1);
ini_set('display_errors',1);
/**
 * Common config values all subdomains and CLI will be using
 */
//generic paths
\define('CORE_PATH', 		__DIR__ . '/..');
\define('APP_PATH', 		CORE_PATH . '/application');
\define('SHOW_EXCEPTIONS',1);      //DEFINE THIS IF U WANT EXCEPTIONS TO RETURN FULL STACKS TO CLIENT

\ini_set('include_path', '.' .
    PATH_SEPARATOR . APP_PATH .
	PATH_SEPARATOR . CORE_PATH . '/src'
);
</TalisDemoApp>

<TalisFramework path="/README.md">
# TalisMS
TalisMS is a PHP framework for fast prototyping systems in a Micro Service eco system

Folder structure
================
Talis  - library/framework code  
public - doc root for web servers  
init   - bootstrap/config code  
environemnt - environment files (dev/qa/production etc)  
application - business specific code, not part of the library  
tests  - utilities to qa/test your code   
tests/lib - some utilities to enable quick demo writing  

db_gems folder hosts the Rahl Commander DB assets and tests.
bin folder is for backend processes / cli tools.
doors folder is to handle requests from other apps/clients.
application/api is where we define the Actions (good idea to have one abstract action per folder, if all actions in folder share same dependencies/filters)  
application/model is where we model the business logic in a middleware way + auziliary helper classes, like IDUhubs  
application/lib is low level code/library, specific for this project (otherwise, consider putting it in TalisMS)  
application/aux is for auxiliary classes for specific data sources elements, like the IDUHubs  
</TalisFramework>

<TalisDoor type="main_router" path="/doors/standalone/main_router.php">
<?php

if (preg_match('/\.(?:png|jpg|jpeg|gif|js|html|css)$/', $_SERVER["REQUEST_URI"])) {
    return false;    // serve the requested resource as-is.
}
require_once '../../config/bootstrap.php';

//IF you want all the API to be under a sub directory or a few level deep i.e. /api or /api/v0

// localhost:8000/api/talis/discovery
(new \Talis\Doors\Rest)->gogogo('/api');

// localhost:8000/api/v0/talis/discovery
// (new \Talis\Doors\Rest)->gogogo('/api/v0');

// localhost:8000/talis/discovery
// (new \Talis\Doors\Rest)->gogogo('');
</TalisDoor>

<TalisDoor type="i-am-static.html" path="/doors/standalone/i-am-static.html">
<html>
	<body>
		<h3>Hello</h3>
		<h4>I am a static web page</h4>
	</body>
</html>
</TalisDoor>

<TalisDoor type="kickstart.sh" path="/doors/standalone/kickstart.sh">
php -S localhost:8000 main_router.php
</TalisDoor>

<TalisDoor type="brew_lord_commander" path="/doors/cli/brew_lord_commander">
#!/opt/homebrew/bin/php
<?php
require_once __DIR__ . '/../../config/bootstrap.php';
(new \Talis\Doors\Cli)->gogogo($argv[1],$argv[2],$argv[3]??false);
</TalisDoor>

<TalisDoor type="lord_commander" path="/doors/cli/lord_commander">
#!/bin/php
<?php
//require_once __DIR__ . '/../../config/environment/'.lifeCycle().'.php';

//require_once app_env()['paths']['root_path']. '/config/bootstrap.php';
require_once __DIR__ . '/../../config/bootstrap.php';
(new \Talis\Doors\Cli)->gogogo($argv[1],$argv[2],$argv[3]??false);
</TalisDoor>

<TalisDoor type="environment.py" path="/doors/daemon/environment.py">
#queue or topic
queue_or_topic      = "queue"
queue_or_topic_name = "talis"
logfile             = '/var/log/lms2/talis_listener_daemon.log'
pidfile             = '/tmp/talislistener.pid'
the_devil           = '/home/admin/dev/talisms/doors/daemon/the_devil.php'
</TalisDoor>

<TalisDoor type="the_devil" path="/doors/daemon/the_devil.php">
#!/bin/php
<?php
require_once __DIR__ . '/../../config/environment/you_need_to_have_a_file_here.php';
require_once app_env()['paths']['root_path']. '/config/bootstrap.php';
(new \Talis\Doors\Daemon)->gogogo($argv[1]);
exit(0);
</TalisDoor>

<TalisDoor type="listener.py" path="/doors/daemon/listener.py">
#!/usr/local/bin/python2.7

import sys
import os
import time
import logging
import smtplib
import socket
import environment as MyENV

from stompest.config import StompConfig
from stompest.protocol import StompSpec
from stompest.sync import Stomp
from subprocess import check_output
from daemon import runner
from logging.handlers import TimedRotatingFileHandler
from subprocess import CalledProcessError
from base64 import b64encode

LOGFILE = MyENV.logfile
PIDFILE = MyENV.pidfile
STDIN = '/dev/null'
STDOUT = '/dev/tty'
STDERR = '/dev/tty'
TIMEOUT = 5

processgid=0 # 1048 apache, run as root for now
processuid=0 # 1048 apache, run as root for now

hostname=socket.gethostname()

class TalisDaemon():
    def __init__(self):
        self.stdin_path = STDIN
        self.stdout_path = STDOUT
        self.stderr_path = STDERR
        self.pidfile_path =  PIDFILE
        self.pidfile_timeout = TIMEOUT

    def run(self):
        if(processgid > 0): os.setgid(processgid)
        if(processuid > 0): os.setuid(processuid)
        config = StompConfig('tcp://localhost:61613')
        topic = "/%s/%s" % (MyENV.queue_or_topic,MyENV.queue_or_topic_name) #"/queue/talis"
        client = Stomp(config)
        self.logger = logging.getLogger(MyENV.queue_or_topic_name) 
        self.logger.setLevel(logging.DEBUG)
        handler = TimedRotatingFileHandler(LOGFILE, when='midnight', interval=1, backupCount=30)
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)

        try:
            self.logger.info("Daemon started with pid %d" % os.getpid())
            client.connect()
            client.subscribe(topic, {StompSpec.ACK_HEADER: StompSpec.ACK_CLIENT_INDIVIDUAL})
            self.logger.info("started listening")
            while True:
                frame = client.receiveFrame()
                body = frame.body
                self.logger.info("Received Frame [%s]" % body)
                encoded_body = b64encode(body)
                cmd = "%s %s" % (MyENV.the_devil,encoded_body)
                try:
                    check_output(cmd, shell=True)
                except CalledProcessError, e:
                    msg = "The devil failed with cmd %s exit status %d and output: %s" % (e.cmd, e.returncode, e.output)
                    self.logger.error(msg)
                client.ack(frame)
                
                    
        except Exception, e:
            msg = "Exception in %s: %s" % (sys.argv[0], str(e))
            self.logger.error(msg)
            exit(1)
            
if(sys.argv[1]=="status"):
    if(os.path.exists(PIDFILE)):
        pid = int(open(PIDFILE,"r").read())
        try:
            os.kill(pid,0)
            exit(0)
        except Exception, e:
            exit(1)
    else:
        exit(1)
        
app = TalisDaemon()
daemon_runner = runner.DaemonRunner(app)
daemon_runner.do_action()
</TalisDoor>

<TalisDoor type="index" path="/doors/http/index.php">
<?php
require_once __DIR__ . '/../../config/environment/'.lifeCycle().'.php';
require_once app_env()['paths']['root_path']. '/config/bootstrap.php';
(new \Talis\Doors\HTTP)->gogogo(app_env()['paths']['root_uri']);
</TalisDoor>

<TalisDoor type="crossdomain.xml" path="/doors/http/crossdomain.xml">
<?xml version="1.0"?>
<cross-domain-policy>
    <allow-access-from domain="*" to-ports="*" />
</cross-domain-policy>
</TalisDoor>

<TalisDoor type=".htaccess" path="/doors/http/.htaccess">
rewriteEngine on
# if a directory or a file exists, use it directly
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d

# otherwise forward it to index.php
RewriteRule . index.php

</TalisDoor>

<TalisDoor type="index" path="/doors/rest/index.php">
<?php
require_once __DIR__ . '/../../config/environment/'.lifeCycle().'.php';
require_once app_env()['paths']['root_path']. '/config/bootstrap.php';
(new \Talis\Doors\Rest)->gogogo(app_env()['paths']['root_uri']);
</TalisDoor>

<TalisDoor type="crossdomain.xml" path="/doors/rest/crossdomain.xml">
<?xml version="1.0"?>
<cross-domain-policy>
    <allow-access-from domain="*" to-ports="*" />
</cross-domain-policy>
</TalisDoor>

<TalisDoor type=".htaccess" path="/doors/rest/.htaccess">
rewriteEngine on
# if a directory or a file exists, use it directly
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d

# otherwise forward it to index.php
RewriteRule . index.php

</TalisDoor>

<TalisDemoApp path="/application/model/README.md">
model the business logic in this folder.  
Preferably use the middleware approach.
</TalisDemoApp>

<TalisDemoApp path="/application/lib/README.md">
Library files specific for this project.
Consider adding those to TalisMS
</TalisDemoApp>

<TalisDemoApp path="/application/api/test/ping/read.php">
<?php namespace Api;
/**
 * Responsebility: Parses the user input to identify the API class to instantiate
 *
 * Notice last element in the chain must implement  \Talis\commons\iRenderable
 * otherwise the response can not be rendered and it will error out after the last chainlink is processed
 * 
 * @author Itay Moav
 * @Date  2017-05-19
 */
class TestPingRead extends \Talis\Chain\aFilteredValidatedChainLink
{

    protected function get_next_bl(): array
    {
        return [
            [Ping::class,[]  ],
            [\Talis\Chain\DoneSuccessfull::class,[] ]
        ];
    }
}

class Ping extends \Talis\Chain\aChainLink
{
    public function process(): \Talis\Chain\aChainLink
    {
        $payload = new \stdClass;
        $payload->type = 'test';
        $payload->message = 'boom';
        $payload->params = print_r($this->Request->getAllGetParams(), true);
        $payload->body = print_r($this->Request->getBody(), true);
        $this->Response->setPayload($payload);
        return $this;
    }
}
</TalisDemoApp>

<TalisDemoApp path="/application/api/test/dependency/create.php">
<?php namespace Api;

/**
 * Responsebility: Parses the user input to identify the API class to instantiate
 *
 * Notice last element in the chain must implement  \Talis\commons\iRenderable
 * otherwise the response can not be rendered and it will error out after the last chainlink is processed
 * 
 * @author Itay Moav
 * @Date  2017-05-19
 */
class TestDependencyCreate extends \Talis\Chain\aFilteredValidatedChainLink{

	protected array $filters                  = [];
	
	protected array $dependencies 			  = [
			  		[\Talis\Chain\Dependencies\GetFieldExist::class,['field'=>'user']],
			  		[\Talis\Chain\Dependencies\GetFieldExist::class,['field'=>'baba']],
			  ]
	;
			  
	/**
	 * a default way to finish a chain.
	 * Mostly for debug purposes
	 * 
	 * @return array<array>
	 * 
	 * @see \Talis\Chain\AFilteredValidatedChainLink::get_next_bl()
	 */
	protected function get_next_bl():array{
		return [[\Talis\Chain\DoneSuccessfull::class,[]]];
	}
}
</TalisDemoApp>

<TalisDemoApp path="/application/api/test/filter/read.php">
<?php namespace Api;

/**
 * Responsebility: Parses the user input to identify the API class to instantiate
 * 
 * Notice last element in the chain must implement  \Talis\commons\iRenderable
 * otherwise the response can not be rendered and it will error out after the last chainlink is processed
 * 
 * @author Itay Moav
 * @Date  2017-05-19
 */
class TestFilterRead extends \Talis\Chain\aFilteredValidatedChainLink{
	protected $filters                  = [
			[\Talis\Chain\Filters\TransformParam::class,['mumble','blabla','brumbrum']]
	],
		      $dependencies 			= [
				[\Talis\Chain\Dependencies\HasBody::class,[]]
	]
	
	;
	
	/**
	 * a default way to finish a chain.
	 * Mostly for debug purposes
	 *
	 * @see \Talis\Chain\AFilteredValidatedChainLink::get_next_bl()
	 */
	protected function get_next_bl():array{
		return [[\Talis\Chain\DoneSuccessfull::class,[]]];
	}
}
</TalisDemoApp>

<TalisDemoApp path="/application/api/talis/ping/read.php">
<?php namespace Api;
class TalisPingRead extends \Talis\Chain\aFilteredValidatedChainLink{
    
    /**
     * If I got here, it means the dependencies where satisified.
     * The next link is where we route depending on the Action value
     * 
     * Notice last element in the chain must implement  \Talis\commons\iRenderable
     * otherwise the response can not be rendered and it will error out after the last chainlink is processed
     * 
     * @return array with single or more BL aChainLink objects
     */
    protected function get_next_bl():array{
        return [
            [Pong::class,[]]
        ];
    }
}



/**
 * Return basic response to confirm chain operation and input capture
 */
class Pong extends \Talis\Chain\aChainLink implements \Talis\commons\iRenderable{
    public function process():\Talis\Chain\aChainLink{
        $this->Response->setMessage('PONG ... PING PONG!');
        $this->Response->setStatus(new \Talis\Message\Status\Code200);
        $this->Response->markResponse();
        return $this;
    }
    
    /**
     *
     * {@inheritDoc}
     * @see \Talis\commons\iRenderable::render()
     */
    public function render(\Talis\commons\iEmitter $emitter):void{
        \dbgn($this->Request->getUri() . ' PONG !');
        $emitter->emit($this->Response);
    }
}
</TalisDemoApp>

<TalisDemoApp path="/application/api/talis/discovery/read.php">
<?php namespace Api;
/**
 * Discovery will list ALL APIs possible.
 * MAKE SURE TO DISABLE ON PUBLIC SITES, Or put under log in only users
 * 
 * @author Itay Moav
 * @Date  2020-06-25
 */
class TalisDiscoveryRead extends \Talis\Chain\aFilteredValidatedChainLink{
    
    /**
     * Recursively reads all PHP files in the API directory to build the API discovery list
     * Notice last element in the chain must implement  \Talis\commons\iRenderable
     * otherwise the response can not be rendered and it will error out after the last chainlink is processed
     */
    protected function get_next_bl():array{
        return [
            [ScrapAPIs::class,[]],            
            [\Talis\Chain\DoneSuccessfull::class,[]]
        ];
    }
}

/**
 * Recursively reads all PHP files in the API directory to build the API discovery list
 * @author itay
 *
 */
class ScrapAPIs extends \Talis\Chain\aChainLink
{
    public function process(): \Talis\Chain\aChainLink
    {
        $api_path = APP_PATH . '/api';
        $apis = $this->getDirContents($api_path);
        $filtered_apis = [];
        foreach($apis as $api){
            if(strpos($api,'.php')){
                dbgn($api);
                $filtered_apis[] = str_replace('.php','',explode($api_path,$api)[1]);
            }
        }
        
        $payload = new \stdClass;
        $payload->list = $filtered_apis;
        $this->Response->setPayload($payload);
        return $this;
    }
    
    /**
     * @param string $dir
     * @return array
     */
    private function getDirContents(string $dir):array{
        $results = [];
        $files =  array_diff(scandir($dir), ['..', '.']);
        
        foreach($files as $value){
            //dbgn($value);
            if(!is_dir("{$dir}/{$value}")){
                $results[] = "{$dir}/{$value}";
            } elseif(is_dir("{$dir}/{$value}")) {
                $results[] = "{$dir}/{$value}";
                $results = array_merge($results,$this->getDirContents("{$dir}/{$value}"));
            }
        }
        return $results;
    }
}
</TalisDemoApp>

<TalisDemoApp path="/application/aux/RedisHub/README.md">
Schema files and managment for Redis stored entities.
</TalisDemoApp>

<TalisDemoApp path="/application/aux/README.md">
Auxiliary classes specific for this business domain/app
</TalisDemoApp>

<TalisDemoApp path="/application/aux/IDUHub/README.md">
Specific mysql tables access classes.
</TalisDemoApp>

<TalisFramework path="/composer.json">
{
	"name": "director-moav/talis-ms",
	"description": "TalisMS Is an API framework /  middleware styled framework with multiple Door(r) types to invoke it",
	"type": "git",
	"keywords": [
		"TalisMS",
		"php",
		"middleware"
	],
	"require": {
		"php": ">=8.3.0"
	},
	"autoload": {
		"psr-0": {
			"Talis": "src/"
		}
	},
	"authors": [
		{
			"name": "Itay Moav",
			"homepage": "https://cookinginbinary.blog",
			"role": "Superman"
		}
	],
	"support": {
		"issues": "https://github.com/itay-moav/TalisMS/issues"
	},
	"require-dev": {
		"phpstan/phpstan": "^1.11"
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/commons/iLogger.php">
<?php namespace Talis\commons;
/**
 * 
 * @author itay
 * @date 2024-07-24
 * 
 * The library files has various log calles to emit debug/info/warning/error/fatal messages.
 * You can send those log messages anywere you want and use which ever logger mechanizem you want.
 * All you need to do is write a thin wrapper around the logger you will use which implements 
 * the following interface.
 * 
 * Below the interface I provide a default dev/null logger which u can use if u prefer not to have a logger
 * IT IS NOT set as the default, YOU must do it in the bootstrap file (see example in /TalisMS/config/
 *
 */
interface iLogger{
   
    /**
     *
     * @param mixed $inp : The piece you want to send the log. Make sure it isa datatype your logger can handle
     */
    public function debug(mixed $inp):void;
    
    /**
     *
     * @param mixed $inp : The piece you want to send the log. Make sure it isa datatype your logger can handle
     * @param bool $full_stack : A boolean flag to tell the logger (if it has this capability, otherwise just send false) to add
     *                           some default stuff to the log entry (can be trace, some stats, SESSION etc)
     */
    public function info(mixed $inp,bool $full_stack):void;
    
    /**
     *
     * @param mixed $inp : The piece you want to send the log. Make sure it isa datatype your logger can handle
     * @param bool $full_stack : A boolean flag to tell the logger (if it has this capability, otherwise just send false) to add
     *                           some default stuff to the log entry (can be trace, some stats, SESSION etc)
     */
    public function warning(mixed $inp,bool $full_stack):void;
    
    /**
     *
     * @param mixed $inp : The piece you want to send the log. Make sure it isa datatype your logger can handle
     * @param bool $full_stack : A boolean flag to tell the logger (if it has this capability, otherwise just send false) to add
     *                           some default stuff to the log entry (can be trace, some stats, SESSION etc)
     */
    public function error(mixed $inp,bool $full_stack):void;
    
    /**
     *
     * @param mixed $inp : The piece you want to send the log. Make sure it isa datatype your logger can handle
     * @param bool $full_stack : A boolean flag to tell the logger (if it has this capability, otherwise just send false) to add
     *                           some default stuff to the log entry (can be trace, some stats, SESSION etc)
     */
    public function fatal(mixed $inp,bool $full_stack):void;   
}



/**
 * A bullshit logger you can use if u do not want a logger.
 * Add it in the bootstrap (see the example in the config/bootsrap)
 */
class NullLogger implements iLogger{
    /**
     *
     * @param mixed $inp : The piece you want to send the log. Make sure it isa datatype your logger can handle
     */
    public function debug(mixed $inp):void{
        //boo
    }
    
    /**
     *
     * @param mixed $inp : The piece you want to send the log. Make sure it isa datatype your logger can handle
     * @param bool $full_stack : A boolean flag to tell the logger (if it has this capability, otherwise just send false) to add
     *                           some default stuff to the log entry (can be trace, some stats, SESSION etc)
     */
    public function info(mixed $inp,bool $full_stack):void{
        //boo
    }
    
    /**
     *
     * @param mixed $inp : The piece you want to send the log. Make sure it isa datatype your logger can handle
     * @param bool $full_stack : A boolean flag to tell the logger (if it has this capability, otherwise just send false) to add
     *                           some default stuff to the log entry (can be trace, some stats, SESSION etc)
     */
    public function warning(mixed $inp,bool $full_stack):void{
        //boo
    }
    
    /**
     *
     * @param mixed $inp : The piece you want to send the log. Make sure it isa datatype your logger can handle
     * @param bool $full_stack : A boolean flag to tell the logger (if it has this capability, otherwise just send false) to add
     *                           some default stuff to the log entry (can be trace, some stats, SESSION etc)
     */
    public function error(mixed $inp,bool $full_stack):void{
        //boo
    }
    
    /**
     *
     * @param mixed $inp : The piece you want to send the log. Make sure it isa datatype your logger can handle
     * @param bool $full_stack : A boolean flag to tell the logger (if it has this capability, otherwise just send false) to add
     *                           some default stuff to the log entry (can be trace, some stats, SESSION etc)
     */
    public function fatal(mixed $inp,bool $full_stack):void{
        //boo
    }   
}
</TalisFramework>

<TalisFramework path="/src/Talis/commons/iRenderable.php">
<?php namespace Talis\commons;
/**
 * A link of chainlinks must end with a chainlink that implements this
 * interface.
 * This is to assure Response is properly emmited.
 * 
 * @author itay
 *
 */
interface iRenderable{
	public function render(\Talis\commons\iEmitter $emitter):void;
}
</TalisFramework>

<TalisFramework path="/src/Talis/commons/iEmitter.php">
<?php namespace Talis\commons;
interface iEmitter{
	/**
	 * Emits the input message according to the proper protocol
	 * @param \Talis\Message\Response $message
	 */
	public function emit(\Talis\Message\Response $message):void;
}
</TalisFramework>

<TalisFramework path="/src/Talis/commons/iFilter.php">
<?php namespace Talis\commons;
interface iFilter{
	/**
	 * gets as input a message. MODIFIES THE ACTUAL MESSAGE which is pased by reference.
	 * returns NOTHING!
	 * BE AWARE THIS IS AGAINST THE CURRENT buzz to go fully immutable!
	 *  
	 * @param \Talis\Message\Request $Request
	 */
	public function filter(\Talis\Message\Request $Request):void;
}
</TalisFramework>

<TalisFramework path="/src/Talis/Message/Renderers/HTTP.php">
<?php namespace Talis\Message\Renderers;
/**
 * This is what we know as VIEW, it does the actual echo.
 * This one is for REST responses (aka headers+JSON)
 * 
 * @author Itay Moav
 * @date 2017-05-30
 */
class HTTP implements \Talis\commons\iEmitter{
    /**
     * Formats and echoes the results headers and then body
     * {@inheritDoc}
     * @see \Talis\commons\iEmitter::emit()
     */
	public function emit(\Talis\Message\Response $message):void{
		$stat   = $message->getStatus()->getCode();
		$explanation = $message->getStatus()->getMsg();
		$header = "HTTP/1.1 {$stat} {$explanation}";
		header($header);
		header('Content-Type: application/json; charset=utf-8');
		$all_other_headers = $message->getHeaders();
		\Talis\TalisMain::logger()->debug('SENDING HEADERS');
		\Talis\TalisMain::logger()->debug([$header] + $all_other_headers);
		if($all_other_headers){
		    foreach($all_other_headers as $other_header){
		        header($other_header);
		    }
		}
		$body = json_encode($message->getBody());
		if($body === false){
		    throw new \Exception('Could not json encode the payload');
		}
		\Talis\TalisMain::logger()->debug('SENDING BODY');
		\Talis\TalisMain::logger()->debug($body);
		echo $body;
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Message/Renderers/Cli.php">
<?php namespace Talis\Message\Renderers;
/**
 * This is what we know as VIEW, it does the actual echo.
 * This one is for Cli responses (aka emit text + exit(status)
 * 
 * @author Itay Moav
 * @date 2017-06-07
 */
class Cli implements \Talis\commons\iEmitter{
    /**
     * Formats and echoes the results headers and then body
     * 
     * {@inheritDoc}
     * @see \Talis\commons\iEmitter::emit()
     */
	public function emit(\Talis\Message\Response $message):void{
		$stat = $message->getStatus()->getCode();
		$body = json_encode($message->getBody(),JSON_PRETTY_PRINT);
		echo $body;
		echo "\nFIN with [{$stat}]\n";
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Message/Renderers/Log.php">
<?php namespace Talis\Message\Renderers;
/**
 * This is what we know as VIEW, it does the actual echo.
 * This one is for Cli responses (aka emit text + exit(status)
 * 
 * @author Itay Moav
 * @date 2017-06-07
 */
class Log implements \Talis\commons\iEmitter{
    
    /**
     * Formats and echoes the results headers and then body
     * 
     * {@inheritDoc}
     * @see \Talis\commons\iEmitter::emit()
     */
	public function emit(\Talis\Message\Response $message):void{
		$body = json_encode($message->getBody());
		if($message->getResponseType() != \Talis\Message\Response::RESPONSE_TYPE__RESPONSE){
		    \Talis\TalisMain::logger()->fatal("CHAIN BROKE {$body}",true);
		} else {
		    \Talis\TalisMain::logger()->debug('END OF PROCESS');
		    \Talis\TalisMain::logger()->debug($body);
		}
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Message/Response.php">
<?php namespace Talis\Message;
class Response{
	const RESPONSE_TYPE__RESPONSE   = 'response',
		  RESPONSE_TYPE__DEPENDENCY = 'dependency',
		  RESPONSE_TYPE__ERROR      = 'error'
	;
	
	/**
	 * @var array<string>
	 */
	private array $headers      = [];
    /**
     * @var ?\stdClass
     */
	private ?\stdClass $body    = null;
	/**
	 * @var aStatus
	 */
	private aStatus $status;
	
	/**
	 * @var string
	 */
	private string $message	    = '';

	/**
	 * @var string
	 */
	private string $type		= self::RESPONSE_TYPE__RESPONSE;
	
	/**
	 * @var mixed
	 */
	private $payload	        = null;
	
	/**
	 * 
	 */
	public function __construct(){
		$this->body = new \stdClass;
	}
	
	/**
	 * @return array<string>
	 */
	public function getHeaders():array{
	    return $this->headers;
	}
	
	/**
	 * @param string $header
	 * @return Response
	 */
	public function setHeader(string $header):Response{
	    $this->headers[] = $header;
	    return $this;
	}
    
	/**
	 * @param \stdClass $body
	 * @return \stdClass
	 */
	public function setBody(\stdClass $body):\stdClass{
	    return $this->body = $body;
	}
    
	/**
	 * @param aStatus $status
	 * @return aStatus
	 */
	public function setStatus(aStatus $status):aStatus{
		return $this->status = $status;
	}
	
	/**
	 * @return aStatus
	 */
	public function getStatus():aStatus{
		return $this->status;
	}
	
	/**
	 * @param string $msg
	 * @return string
	 */
	public function setMessage(string $msg):string{
		return $this->message = $msg;
	}
	
	/**
	 * @return string
	 */
	public function getMessage():string{
		return $this->message;
	}
	
	/**
	 * @param mixed $payload
	 * @return mixed
	 */
	public function setPayload($payload){
		return $this->payload = $payload;
	}
	
	/**
	 * @return mixed
	 */
	public function getPayload(){
	    if(!$this->payload){
	        $this->payload = new \stdClass;
	    }
		return $this->payload;
	}
	
	/**
	 * 
	 */
	public function markError():void{
		$this->type=self::RESPONSE_TYPE__ERROR;
	}
	
	/**
	 * 
	 */
	public function markDependency():void{
		$this->type=self::RESPONSE_TYPE__DEPENDENCY;
	}

	/**
	 * 
	 */
	public function markResponse():void{
		$this->type=self::RESPONSE_TYPE__RESPONSE;
	}
	
	/**
	 * @return string
	 */
	public function getResponseType():string{
		return $this->type;
	}
	
	/**
	 * Carefull, it rebuilds the body each time from it's parts
	 * 
	 * {@inheritDoc}
	 * @see \Talis\Message\Response::getBody()
	 */
	public function getBody():\stdClass{
	    $body = new \stdClass;
	    $status = $this->getStatus();
	    $body->status  = "{$status->getCode()} {$status->getMsg()}";
		$body->type    = $this->type;
		$body->message = $this->getMessage();
		$body->payload = $this->getPayload();
		return $this->setBody($body);
	}
	
	/**
	 *
	 * @return string
	 */
	public function __toString():string{
	    $j = json_encode($this->getBody());
	    return $j ?: '' ;
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Message/aStatus.php">
<?php namespace Talis\Message;
abstract class aStatus{
    
    /**
     * @var int
     */
    protected int $code;
    
    /**
     * @var string
     */
    protected string $msg;
    
    /**
     * @var string
     */
    protected string $dyn_error_msg = '';
	
    /**
     * 
     * @return int
     */
	public function getCode():int{
		return $this->code;
	}

	/**
	 * 
	 * @return string
	 */
	public function getMsg():string{
		return $this->msg;
	}
	
	/**
	 * @param string $msg
	 * @return string
	 */
	public function dynamic_message(string $msg):string{
		$this->dyn_error_msg = $msg;
		return $this->dyn_error_msg;
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Message/Status/Code422.php">
<?php namespace Talis\Message\Status;
class Code422 extends \Talis\Message\aStatus{
    /**
     * @var int
     */
    protected int $code = 422;
    
    /**
     * @var string
     */
    protected string $msg = 'Unprocessable Entity';
}
</TalisFramework>

<TalisFramework path="/src/Talis/Message/Status/Code200.php">
<?php namespace Talis\Message\Status;
class Code200 extends \Talis\Message\aStatus{
    /**
     * @var int
     */
    protected int $code = 200;
    
    /**
     * @var string
     */
    protected string $msg = 'Oook';
}
</TalisFramework>

<TalisFramework path="/src/Talis/Message/Status/Code201.php">
<?php namespace Talis\Message\Status;
class Code201 extends \Talis\Message\aStatus{
    /**
     * @var int
     */
    protected int $code = 201;
    
    /**
     * @var string
     */
    protected string $msg = 'Resource Created';
}
</TalisFramework>

<TalisFramework path="/src/Talis/Message/Status/Code404.php">
<?php namespace Talis\Message\Status;
class Code404 extends \Talis\Message\aStatus{
    /**
     * @var int
     */
    protected int $code = 404;
    
    /**
     * @var string
     */
    protected string $msg = 'Not Found';
}
</TalisFramework>

<TalisFramework path="/src/Talis/Message/Status/Code202.php">
<?php namespace Talis\Message\Status;
class Code202 extends \Talis\Message\aStatus{
    /**
     * @var int
     */
    protected int $code = 202;
    
    /**
     * @var string
     */
    protected string $msg = 'Accepted';
}
</TalisFramework>

<TalisFramework path="/src/Talis/Message/Status/Code400.php">
<?php namespace Talis\Message\Status;
class Code400 extends \Talis\Message\aStatus{
    /**
     * @var int
     */
    protected int $code = 400;
    
    /**
     * @var string
     */
    protected string $msg = 'Bad Request';
}
</TalisFramework>

<TalisFramework path="/src/Talis/Message/Status/Code401.php">
<?php namespace Talis\Message\Status;
/**
 * User is not logged in
 * @author itay
 *
 */
class Code401 extends \Talis\Message\aStatus{
    /**
     * @var int
     */
    protected int $code = 401;
    
    /**
     * @var string
     */
    protected string $msg = 'Unauthorized';
}
</TalisFramework>

<TalisFramework path="/src/Talis/Message/Status/Code403.php">
<?php namespace Talis\Message\Status;
/**
 * User is logged in, but is not authorized here
 * 
 * @author itay
 *
 */
class Code403 extends \Talis\Message\aStatus{
    
    /**
     * @var int
     */
    protected int $code = 403;
    
    /**
     * @var string
     */
    protected string $msg = 'Forbbiden';
}
</TalisFramework>

<TalisFramework path="/src/Talis/Message/Status/Code204.php">
<?php namespace Talis\Message\Status;
class Code204 extends \Talis\Message\aStatus{
    
    /**
     * @var int
     */
    protected int $code = 204;
    
    /**
     * @var string
     */
    protected string $msg = 'No Content';
}
</TalisFramework>

<TalisFramework path="/src/Talis/Message/Status/Code500.php">
<?php namespace Talis\Message\Status;
class Code500 extends \Talis\Message\aStatus{
    /**
     * @var int
     */
    protected int $code = 500;
    
    /**
     * @var string
     */
    protected string $msg = 'Server Error';
}
</TalisFramework>

<TalisFramework path="/src/Talis/Message/Request.php">
<?php namespace Talis\Message;
class Request{
    /**
     * @var array<string>
     */
    private array $headers = [];
    
    /**
     * @var \stdClass
     */
    private \stdClass $body;
    
    /**
     * @var string
     */
    private string $full_uri;
    
    /**
     * @var array<string>
     */
    private array $get_params = [];
	
    /**
     * @param string $full_uri
     * @param array<string> $get_params
     * @param ?\stdClass $body
     */
	public function __construct(string $full_uri,array $get_params,?\stdClass $body=null){
		$this->body       = $body?:new \stdClass;
		$this->full_uri   = $full_uri;
		$this->get_params = $get_params;
	}
	
	/**
	 * 
	 * @return array<string,string>
	 */
	public function __serialize(): array{
	    return [
	        'headers'    => serialize($this->headers),
	        'body'       => serialize($this->body),
	        'full_uri'   => urlencode($this->full_uri),
	        'get_params' => serialize($this->get_params)
	    ];
	}
	
	/**
	 * 
	 * @param array<string,string> $data
	 */
	public function __unserialize(array $data): void{
	    $this->headers     = unserialize($data['headers']);
	    $this->body        = unserialize($data['body']);
	    $this->full_uri    = urldecode($data['full_uri']);
	    $this->get_params  = unserialize($data['get_params']);
	}
	
	/**
	 * @return array<string>
	 */
	public function getHeaders():array{
	    return $this->headers;
	}
	
	/**
	 * @param string $header
	 * @return Request
	 */
	public function setHeader(string $header):Request{
	    $this->headers[] = $header;
	    return $this;
	}
	
	/**
	 * The json decoded body or stdClass
	 *
	 * @return \stdClass
	 */
	public function getBody():\stdClass{
	    return $this->body??$this->setBody(new \stdClass);
	}

	/**
	 * @param \stdClass $body
	 * @return \stdClass
	 */
	public function setBody(\stdClass $body):\stdClass{
	    return $this->body = $body;
	}

	/**
	 * Full URI of this request (API+get params)
	 * @return string
	 */
	public function getUri():string{
		return $this->full_uri;		
	}
	
	/**
	 * 
	 * @return array<string>
	 */
	public function getAllGetParams():array{
		return $this->get_params;
	}
	

	/**
	 * the url/param/value or a default 
	 * 
	 * @param string $key
	 * @param ?string $default
	 * @return ?string
	 * @deprecated
	 */
	public function get_param(string $key,?string $default=null):?string{
	    return $this->get_params[$key] ?? $default;
	}
	
	/**
	 * The url/param/value or NULL
	 * 
	 * @param string $key
	 * @return string|NULL
	 */
	public function get_param_null(string $key):?string{
	    return $this->get_params[$key] ?? null;
	}
	
	/**
	 * The url/param/value or a default 
	 * 
	 * @param string $key
	 * @param string $default
	 * @return string
	 */
	public function get_param_default(string $key,string $default):string{
	    return $this->get_params[$key] ?? $default;
	}
	
	/**
	 * the url/param/value
	 * This can be called if you are sure the param exists
	 * 
	 * @param string $key
	 * @return string
	 */
	public function get_param_exists(string $key):string{
	    return $this->get_params[$key];
	}
	
	/**
	 * The url/param/value
	 * Failes if no param found
	 * @param string $key
	 * @throws \Talis\Exception\ParamNotFound
	 * @return string
	 */
	public function get_param_or_fail(string $key):string{
	    if(!isset($this->get_params[$key])){
	        throw new \Talis\Exception\ParamNotFound($key);
	    }
	    return $this->get_params[$key];
	}
	
	
	/**
	 * the body->params 
	 * @return \stdClass
	 */
	public function getBodyParams():\stdClass{
		if(!isset($this->getBody()->params)){
		    $this->body->params = new \stdClass;
		}
		return $this->getBody()->params;
	}
	
    /**
     * The the body->params->key or default value | null
     * 
     * @param string $key
     * @param mixed $default
     * @return mixed
     */
	public function getBodyParam(string $key,$default=null){
	    return $this->getBody()->params->$key ?? $default;
	}
	
	/**
	 * The the body->params->key
	 * This can be called if you are sure the param exists
	 * 
	 * @param string $key
	 * @return mixed
	 */
	public function getBodyParamExists(string $key){
	    return $this->getBody()->params->$key;
	}
	
	/**
	 * The the body->params->key
	 * Failes if no param found
	 * 
	 * @param string $key
	 * @throws \Talis\Exception\ParamNotFound
	 * @return mixed
	 */
	public function getBodyParamOrFail(string $key){
	    if(!isset($this->getBody()->params->$key)){
	        throw new \Talis\Exception\ParamNotFound($key);
	    }
	    return $this->getBody()->params->$key;
	}
	
	/**
	 * Add values/keys to the parameter section of the body->params
	 * @param string $k
	 * @param mixed $v
	 * @return mixed
	 */
	public function addToBodyParams(string $k,$v){
		return $this->getBodyParams()->$k = $v;		
	}

}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/Filters/aFilter.php">
<?php namespace Talis\Chain\Filters;
/**
 * 
 * @author Itay Moav
 * @2017-05-30
 */
abstract class aFilter extends \Talis\Chain\aChainLink implements \Talis\commons\iFilter{
	/**
	 * logic to filter. Do notice, the $message is a ctually the Request in this case
	 */
    abstract public function filter(\Talis\Message\Request $Request):void;

	/**
	 * 
	 * {@inheritDoc}
	 * @see \Talis\Chain\AChainLink::process()
	 */
	final public function process():\Talis\Chain\AChainLink{
		$this->filter($this->Request);
		return $this;
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/Filters/DefaultValueGet.php">
<?php namespace Talis\Chain\Filters;
/**
 * Adds a default value to the GET params, if field does not exists
 *
 */
class DefaultValueGet extends aFilter{
    /**
     * {@inheritDoc}
     * @see \Talis\Chain\Filters\aFilter::filter()
     */
    public function filter(\Talis\Message\Request $Request):void{
	    $field_name     = $this->params['field'];
	    $default        = $this->params['default'];
	    $all_get_params = $this->Request->getAllGetParams();
	    
	    if(!isset($all_get_params[$field_name]) || !$all_get_params[$field_name]){
	       $all_get_params[$field_name] = $default;
	    }
	    
	    $this->Request = new \Talis\Message\Request($Request->getUri(), $all_get_params, $Request->getBody());
	    
	    \Talis\TalisMain::logger()->debug('FILTERED REQUEST');
	    \Talis\TalisMain::logger()->debug($this->Request);
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/Filters/AddGetQueryStringOverriding.php">
<?php namespace Talis\Chain\Filters;
/**
 * Adds the $_GET into the get params. Some other partiers use this
 * This will override existing values.
 *
 */
class AddGetQueryStringOverriding extends aFilter{
    public function filter(\Talis\Message\Request $Request):void{
	    $all_get_params = $this->Request->getAllGetParams();
        $new_all_get_params = array_merge($all_get_params,$_GET);
        $this->Request = new \Talis\Message\Request($Request->getUri(), $new_all_get_params, $Request->getBody());
    
	    \Talis\TalisMain::logger()->debug('FILTERED REQUEST');
	    \Talis\TalisMain::logger()->debug($this->Request);
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/Filters/FormPostIntoGetOverride.php">
<?php namespace Talis\Chain\Filters;
/**
 * Adds the $_POST into the get params. Some other partiers use this
 * This will override existing values.
 */
class FormPostIntoGetOverride extends aFilter{
    /**
     * @param \Talis\Message\Request $Request
     * 
     * {@inheritDoc}
     * @see \Talis\Chain\Filters\aFilter::filter()
     */
    public function filter(\Talis\Message\Request $Request):void{
        \Talis\TalisMain::logger()->debug('POST');
        \Talis\TalisMain::logger()->debug($_POST);
        
        $all_get_params = $this->Request->getAllGetParams();
        $new_all_get_params = array_merge($all_get_params,$_POST);
        $this->Request = new \Talis\Message\Request($Request->getUri(), $new_all_get_params, $Request->getBody());
    }
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/Filters/TransformParam.php">
<?php namespace Talis\Chain\Filters;
/**
 * Looks for a field in the params $params[0], if exists, it changes it from $params[1] to $params[2]
 * @author admin
 *
 */
class TransformParam extends aFilter{
    /**
     * {@inheritDoc}
     * @see \Talis\Chain\Filters\aFilter::filter()
     */
    public function filter(\Talis\Message\Request $Request):void{
        $params = $Request->getBody()->params;

        \Talis\TalisMain::logger()->debug('input params for filter TransformParam');
		\Talis\TalisMain::logger()->debug($params);
		
		if(isset($params->{$this->params[0]}) && $params->{$this->params[0]} == $this->params[1]){
			$params->{$this->params[0]} = $this->params[2];
		}
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/ResourceCreated.php">
<?php namespace Talis\Chain;

/**
 * Responsebility:
 *  reports successfull resource creations (POSTs)
 *  NOTICE! if you want to return the new resource, you need to handle it in your chain links.
 *  
 * @author Itay Moav
 * @Date  2019-05-13
 */
class ResourceCreated extends aChainLink implements \Talis\commons\iRenderable{
    /**
     * {@inheritDoc}
     * @see \Talis\Chain\aChainLink::process()
     */
	public function process():aChainLink{
		$this->Response->setMessage('Resource created');
		$this->Response->setStatus(new \Talis\Message\Status\Code201);
		$this->Response->markResponse();
		return $this;
	}
	
	/**
	 * 
	 * {@inheritDoc}
	 * @see \Talis\commons\iRenderable::render()
	 */
	public function render(\Talis\commons\iEmitter $emitter):void{
	    \Talis\TalisMain::logger()->debug($this->Request->getUri() . ' FINISHED CHAIN WITH SUCCESS');
	    \Talis\TalisMain::logger()->debug('RESPONSE: ');
	    \Talis\TalisMain::logger()->debug($this->Response);
		$emitter->emit($this->Response);
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/DuplicateResource.php">
<?php namespace Talis\Chain;

/**
 * TODO: Move into the error chainlink folder
 *
 * Responsebility:
 * 
 *  Alerts the client that a create call is trying to create a duplicate resource, let's see how client can handle it
 *  
 * @author Itay Moav
 * @Date  2023-03-02
 */
class DuplicateResource extends aChainLink implements \Talis\commons\iRenderable{
    /**
     * {@inheritDoc}
     * @see \Talis\Chain\aChainLink::process()
     */
	public function process():aChainLink{
		$this->Response->setMessage('duplicate resource');
		$this->Response->setStatus(new \Talis\Message\Status\Code422);
		$this->Response->markError();
		return $this;
	}
	
	/**
	 * 
	 * {@inheritDoc}
	 * @see \Talis\commons\iRenderable::render()
	 */
	public function render(\Talis\commons\iEmitter $emitter):void{
	    \Talis\TalisMain::logger()->debug($this->Request->getUri() . ' CHAIN ENDS ABROPTLY: Trying to create a duplicate resource');
	    \Talis\TalisMain::logger()->debug('RESPONSE: ');
	    \Talis\TalisMain::logger()->debug($this->Response);
		$emitter->emit($this->Response);
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/aChainLink.php">
<?php namespace Talis\Chain;


/**
 * Responsebility: 
 *    (JUST) Manages the filters and then the dependency chain a request has.
 *    Last block in the chain (can also be the only one) would be the 
 *    concrete BL object for this request.
 *    
 * @author Itay Moav
 * @Date  2017-05-19
 */
abstract class aChainLink{
	
	/**
	 * @var \Talis\Message\Request $Request
	 */
    protected \Talis\Message\Request $Request;
	
	/**
	 * @var \Talis\Message\Response $Response
	 */
    protected \Talis\Message\Response $Response;
	
	/**
	 * Extra params some classes need
	 * @var array<mixed>
	 */
	protected array $params;

	/**
	 * @var ChainContainer $chain_container
	 */
	protected ChainContainer $chain_container;
	
	/**
	 * @var boolean
	 */
	protected bool $valid = true;
    
	/**
	 * 
	 * @param \Talis\Message\Request $Request
	 * @param \Talis\Message\Response $Response
	 * @param array<mixed> $params
	 */
	public function __construct(\Talis\Message\Request $Request,\Talis\Message\Response $Response,array $params=[]){
		$this->Request  = $Request;
		$this->Response = $Response;
		$this->params   = $params;
	}

	/**
	 * A chain of links that will be (depends on process) processed one after the other.
	 * @param ChainContainer $chain_container
	 */
	public function set_chain_container(ChainContainer $chain_container):void{
		$this->chain_container = $chain_container;
	}
	
	/**
	 * 
	 * @param string $classname
	 * @param array<mixed> $params
	 * @return \Talis\Chain\aChainLink
	 */
	public function append_chainlink(string $classname,array $params=[]):\Talis\Chain\aChainLink{
	    $this->chain_container->push([$classname,$params]);
	    return $this;
	}
	
	/**
	 * Returns a copy of the response object
	 * @return \Talis\Message\Response
	 */
	public function clone_response():\Talis\Message\Response{
	    return clone $this->Response;
	}
	
	/**
	 * Actual logic should happen here.
	 * 99.999999999% it should return itself!
	 * 
	 * @return aChainLink
	 */
	abstract public function process():aChainLink;
	
	/**
	 * Clears the queu, returns the error
	 * 
	 * @param \Talis\Chain\aChainLink $NewLastChainLink
	 * @return \Talis\Chain\aChainLink
	 */
	protected function bail_out(\Talis\Chain\Errors\aError $NewLastChainLink):\Talis\Chain\Errors\aError{
	   $this->chain_container->clear();
	   return $NewLastChainLink->process();
	}
	
	/**
	 * Do the filter chain
	 * Pass the filtered get params and req body and next bl to the dependency chain
	 * Sets the result as the response
	 * 
	 * @return \Talis\Chain\aChainLink
	 * 
	 * @see \Talis\Chain\AChainLink::nextLinkInchain()
	 */
	final public function nextLinkInchain():\Talis\Chain\aChainLink{
	    \Talis\TalisMain::logger()->debug('About to process: [' . get_class($this).']');
		$FinalLink = $this->process();

		//If the returned chain is not a new chain (road diversion) and there are more links in the current chain, go after it.
		if($FinalLink == $this && isset($this->chain_container) && !$this->chain_container->isEmpty()){
			$next_link_class = $this->chain_container->pop();
			$name   = $next_link_class[0];
			$params = $next_link_class[1];
			if(is_callable($name)){
			    \Talis\TalisMain::logger()->debug('STARTING NEXT CHAIN LINK WITH FUNCTION');
			    \Talis\TalisMain::logger()->debug($name);
			    $next_link = new FunctionalChainlinkWrapper($name,$this->Request,$this->Response,$params);
			    
			} else {
    			\Talis\TalisMain::logger()->debug("STARTING NEXT CHAIN LINK WITH {$name}");
    			$next_link = new $name($this->Request,$this->Response,$params);
			}
			
			$next_link->set_chain_container($this->chain_container);
			$FinalLink = $next_link->nextLinkInchain();
		}
		return $FinalLink;
	}
	
	/**
	 * 
	 * @return \Talis\Message\Response
	 */
	public function getResponse():\Talis\Message\Response{
	    return $this->Response;
	}
}

/**
 * 
 * @param callable $func
 * @param \Talis\Message\Request $Request
 * @param \Talis\Message\Response $Response
 * @param array<mixed> $params
 * @param array<mixed> $chain_container
 */
function handleFunctionalChainlink($func,$Request,$Response,$params,$chain_container):void{
    //function can only modify the response and request payloads
    //return is debug only
    $dbg = $func($Request,$Response,$params);
    \Talis\TalisMain::logger()->debug('Functional response ' . print_r($dbg,true));
    
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/ResourceUpdated.php">
<?php namespace Talis\Chain;

/**
 * Responsebility:
 *  reports successfull resource updating (not creating)
 *  
 * @author Itay Moav
 * @Date  2021-04-05
 */
class ResourceUpdated extends aChainLink implements \Talis\commons\iRenderable{
    /**
     * {@inheritDoc}
     * @see \Talis\Chain\aChainLink::process()
     */
	public function process():aChainLink{
		$this->Response->setMessage('Resource updated');
		$this->Response->setStatus(new \Talis\Message\Status\Code204);
		$this->Response->markResponse();
		return $this;
	}
	
	/**
	 * 
	 * {@inheritDoc}
	 * @see \Talis\commons\iRenderable::render()
	 */
	public function render(\Talis\commons\iEmitter $emitter):void{
	    \Talis\TalisMain::logger()->debug($this->Request->getUri() . ' FINISHED CHAIN WITH SUCCESS');
	    \Talis\TalisMain::logger()->debug('RESPONSE: ');
	    \Talis\TalisMain::logger()->debug($this->Response);
		$emitter->emit($this->Response);
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/DoneSuccessfull.php">
<?php namespace Talis\Chain;

/**
 * Responsebility:
 *  Default success message
 *  Emits the final request body 
 *  
 * @author Itay Moav
 * @Date  2017-05-22
 */
class DoneSuccessfull extends aChainLink implements \Talis\commons\iRenderable{
	public function process():aChainLink{
		$this->Response->setMessage('GREAT SUCCESS!');
		$this->Response->setStatus(new \Talis\Message\Status\Code200);
		$this->Response->markResponse();
		return $this;
	}
	
	/**
	 * 
	 * {@inheritDoc}
	 * @see \Talis\commons\iRenderable::render()
	 */
	public function render(\Talis\commons\iEmitter $emitter):void{
	    \Talis\TalisMain::logger()->debug($this->Request->getUri() . ' FINISHED CHAIN WITH SUCCESS');
	    \Talis\TalisMain::logger()->debug('RESPONSE: ');
	    \Talis\TalisMain::logger()->debug($this->Response);
		$emitter->emit($this->Response);
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/Dependencies/GetFieldExist.php">
<?php namespace Talis\Chain\Dependencies;
/**
 * Making sure that a get field exist in the request
 * 
 * @author Itay Moav
 */
class GetFieldExist extends aDependency{
	/**
	 * 
	 * {@inheritDoc}
	 * @see \Talis\Chain\Dependencies\ADependency::validate()
	 */
	protected function validate():bool{
		$valid = isset($this->Request->getAllGetParams()[$this->params['field']]);
		
		\Talis\TalisMain::logger()->debug('validaror ' . self::class);
		\Talis\TalisMain::logger()->debug('params: [' . print_r($this->params,true) . "] is valid? [{$valid}]");
		
		return $valid;
	}
	
	/**
	 * {@inheritDoc}
	 * @see \Talis\commons\iRenderable::render()
	 */
	public function render(\Talis\commons\iEmitter $emitter):void{
		//\dbgr('RENDER',print_r($this->params,true));
		$response = new \Talis\Message\Response;
		$response->markDependency();
		$response->setMessage("Mising URI PARAM {$this->params['field']}");
		$response->setStatus(new \Talis\Message\Status\Code400);
		$emitter->emit($response);
	}		
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/Dependencies/aDependency.php">
<?php namespace Talis\Chain\Dependencies;
/**
 * 
 * @author admin
 *
 */
abstract class aDependency extends \Talis\Chain\aChainLink implements \Talis\commons\iRenderable{
	/**
	 * logic to validate
	 * @return bool
	 */
	abstract protected function validate():bool;

	/**
	 *
	 * {@inheritDoc}
	 * @see \Talis\Chain\AChainLink::process()
	 */
	final public function process():\Talis\Chain\aChainLink{
	    //for clear sake I added this condition...how can we have a dependency with no continuity? There always must be a BL at the end.
	    if($this->chain_container->isEmpty()) {
	        return new \Talis\Chain\Errors\BLLinkMissingInChain($this->Request,new \Talis\Message\Response);
	    }
	    
	    $valid = $this->validate();
	    if(!$valid){
	        $this->chain_container->clear();//stops the chain, render the current
	    }
	    
	    return $this;
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/Dependencies/BodyParamsFieldExist.php">
<?php namespace Talis\Chain\Dependencies;

/**
 * Making sure that a body with params was sent
 * 
 * @author Itay Moav
 */
class BodyParamsFieldExist extends aDependency{
	/**
	 * 
	 * {@inheritDoc}
	 * @see \Talis\Chain\Dependencies\ADependency::validate()
	 */
	protected function validate():bool{
		$body  = $this->Request->getBody();
		$field = $this->params['field'];
		$r = isset($body->params);
		$b = isset($body->params->$field);
		return $r&&$b;
	}
	
	public function render(\Talis\commons\iEmitter $emitter):void{
		
		\Talis\TalisMain::logger()->debug('RENDER input body');
		\Talis\TalisMain::logger()->debug($this->Request->getBody());
		$msg="Mising param [{$this->params['field']}] part in request body->params[]";
		\Talis\TalisMain::logger()->warning($msg,true);
		$response = new \Talis\Message\Response;
		$response->setMessage($msg);
		$response->markDependency();
		$response->setStatus(new \Talis\Message\Status\Code400);
		$emitter->emit($response);
	}		
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/Dependencies/BodyFieldExist.php">
<?php namespace Talis\Chain\Dependencies;

/**
 * Making sure that a body with some field was sent
 * 
 * @author Itay Moav
 */
class BodyFieldExist extends aDependency{
	/**
	 * 
	 * {@inheritDoc}
	 * @see \Talis\Chain\Dependencies\ADependency::validate()
	 */
	protected function validate():bool{
		$body  = $this->Request->getBody();
		$field = $this->params['field'];
		return isset($body->$field);
	}
	
	/**
	 * {@inheritDoc}
	 * @see \Talis\commons\iRenderable::render()
	 */
	public function render(\Talis\commons\iEmitter $emitter):void{

	    \Talis\TalisMain::logger()->debug('RENDER input body');
		\Talis\TalisMain::logger()->debug($this->Request->getBody());
		
		$response = new \Talis\Message\Response;
		$response->setMessage("Mising field [{$this->params['field']}] in request body");
		$response->markDependency();
		$response->setStatus(new \Talis\Message\Status\Code400);
		$emitter->emit($response);
	}		
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/Dependencies/CLIOnly.php">
<?php namespace Talis\Chain\Dependencies;
/**
 * Making sure this is run only via Lord Commander (cli) door
 * 
 * @author Itay Moav
 */
class CLIOnly extends aDependency{
    /**
     *
     * {@inheritDoc}
     * @see \Talis\Chain\Dependencies\ADependency::validate()
     */
    protected function validate():bool{
        $valid = isset($_SERVER['PHP_SELF']) && $_SERVER['PHP_SELF'] === './lord_commander';
        
        \Talis\TalisMain::logger()->debug('validaror ' . self::class);
        \Talis\TalisMain::logger()->debug("Am I using CLI door? [{$valid}]");
        
        return $valid;
    }
    
    /**
     * {@inheritDoc}
     * @see \Talis\commons\iRenderable::render()
     */
    public function render(\Talis\commons\iEmitter $emitter):void{
        //\dbgr('RENDER',print_r($this->params,true));
        $response = new \Talis\Message\Response;
        $response->markDependency();
        $response->setMessage("Accessible only via Lord Commander (cli)");
        $response->setStatus(new \Talis\Message\Status\Code403);
        $emitter->emit($response);
    }
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/Dependencies/GetFieldUInt.php">
<?php namespace Talis\Chain\Dependencies;

/**
 * Making sure that a get field is anm integer
 * 
 * @author Itay Moav
 */
class GetFieldUInt extends aDependency{
	/**
	 * 
	 * {@inheritDoc}
	 * @see \Talis\Chain\Dependencies\ADependency::validate()
	 */
	protected function validate():bool{
	    $field_to_validate = $this->Request->get_param_exists($this->params['field']);
	    if(is_numeric($field_to_validate)){//if numeric, cast to number var type.
	        $field_to_validate = $field_to_validate *1;
	    }
	    $valid = is_integer($field_to_validate) && $field_to_validate >= 0;	    
		
	    \Talis\TalisMain::logger()->debug('validaror ' . self::class);
		\Talis\TalisMain::logger()->debug('params: [' . print_r($this->params,true) . "] is valid? [{$valid}]");
		
		return $valid;
	}
	
	/**
	 * {@inheritDoc}
	 * @see \Talis\commons\iRenderable::render()
	 */
	public function render(\Talis\commons\iEmitter $emitter):void{
		$response = new \Talis\Message\Response;
		$response->markDependency();
		$field = $this->Request->get_param_exists($this->params['field']);
		$response->setMessage("GET PARAM {$this->params['field']} is not an unsigned int, it is: [{$field}]");
		$response->setStatus(new \Talis\Message\Status\Code400);
		$emitter->emit($response);
	}		
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/Dependencies/HasBody.php">
<?php namespace Talis\Chain\Dependencies;
/**
 * Making sure that a body with params was sent
 * 
 * @author Itay Moav
 */
class HasBody extends aDependency{
	/**
	 * 
	 * {@inheritDoc}
	 * @see \Talis\Chain\Dependencies\ADependency::validate()
	 */
	protected function validate():bool{
		return isset($this->Request->getBody()->params) && count($this->Request->getBody()->params);
	}
	
	public function render(\Talis\commons\iEmitter $emitter):void{
		
		\Talis\TalisMain::logger()->debug('RENDER input body');
		\Talis\TalisMain::logger()->debug($this->Request->getBody());
		
		$response = new \Talis\Message\Response;
		$response->markDependency();
		$response->setMessage("Missing body:{params:[...]} part of request");
		$response->setStatus(new \Talis\Message\Status\Code400);
		$emitter->emit($response);
	}		
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/FunctionalChainlinkWrapper.php">
<?php namespace Talis\Chain;


/**
 * Responsebility: 
 *    Wraps functional chainlinks for easier use
 * 
 * Useful for quick logic injection without needing to define a full class
 *    
 * @author Itay Moav
 * @Date  2021-04-08
 */
class FunctionalChainlinkWrapper extends aChainLink{
    
    /**
     * @var callable function to run in process
     */
    private $wrappedFunction;
    
	/**
	 * @param callable $wrappedFunction
	 * @param \Talis\Message\Request $Request
	 * @param \Talis\Message\Response $Response
	 * @param array<mixed> $params
	 */
    public function __construct(callable $wrappedFunction,\Talis\Message\Request $Request,\Talis\Message\Response $Response,array $params){
	    parent::__construct($Request,$Response,$params);
	    $this->wrappedFunction = $wrappedFunction;
	}
	
    /**
     * @return aChainLink
     */
	public function process():aChainLink{
	    $func = $this->wrappedFunction;
	    $func($this->Request,$this->Response,$this->params);
	    return $this;
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/ResourceDeleted.php">
<?php namespace Talis\Chain;

/**
 * Responsebility:
 *  reports successfull resource deleted
 *  
 * @author Itay Moav
 * @Date  2021-04-05
 */
class ResourceDeleted extends aChainLink implements \Talis\commons\iRenderable{
    /**
     * {@inheritDoc}
     * @see \Talis\Chain\aChainLink::process()
     */
	public function process():aChainLink{
		$this->Response->setMessage('Resource deleted');
		$this->Response->setStatus(new \Talis\Message\Status\Code204);
		$this->Response->markResponse();
		return $this;
	}
	
	/**
	 * 
	 * {@inheritDoc}
	 * @see \Talis\commons\iRenderable::render()
	 */
	public function render(\Talis\commons\iEmitter $emitter):void{
	    \Talis\TalisMain::logger()->debug($this->Request->getUri() . ' RESOURCE DELETED!');
	    \Talis\TalisMain::logger()->debug('RESPONSE: ');
	    \Talis\TalisMain::logger()->debug($this->Response);
	    $emitter->emit($this->Response);
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/ChainContainer.php">
<?php namespace Talis\Chain;

/**
 * Manages chainlinks
 * 
 * Each chain link is stored as an array of either a classname (which must inherit from aChainLink) 
 * or a function that returns a function that accepts \Talis\Message\Request $Request,\Talis\Message\Response $Response,array $params
 * example: [[ClassName::class, [param1, param2, ...],[createFunc(), [param1, param2, ...]]
 * 
 * function createFunc():callable{
 *      return function (\Talis\Message\Request $Request,\Talis\Message\Response $Response,array $params){
 *          // do something with Request and params and adds output into Response->getPayload()->someVar=???
 *      }
 * }
 * 
 * The container pushes/pops chain links to be processed in sequence implementing the Chain pattern.
 * 
 * push
 * pop
 * isEmpty
 * debug
 * 
 * @author Itay Moav
 * @date 2021-04-06
 */
class ChainContainer{
    
    /**
     * 
     * @var array
     */
    private array $list_of_chain_links;
    
    /**
     * @param array $list_of_chain_links
     */
    public function __construct(array $list_of_chain_links){
        $this->list_of_chain_links = $list_of_chain_links;
    }

    /**
     * @return aChainLink
     */
    public function pop():array{
        $next_chainlink = array_shift($this->list_of_chain_links);
        return $next_chainlink;
    }

    /**
     * @param array $chainlink
     * @return ChainContainer
     */
    public function push(array $chainlink):ChainContainer{
        $this->list_of_chain_links[] = $chainlink;
        return $this;
    }
    
    /**
     * Clears the chain
     */
    public function clear():void{
        $this->list_of_chain_links=[];
    }
    
    /**
     * @return bool
     */
    public function isEmpty():bool{
        return count($this->list_of_chain_links) === 0;
    }
    
    /**
     */
    public function debug():void{
        foreach($this->list_of_chain_links as $i=>$a_chain_link){
            dbgr("Chain link {$i}",$a_chain_link);
        }
    }
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/aFilteredValidatedChainLink.php">
<?php namespace Talis\Chain;

/**
 * Responsebility: 
 *    Manages the filters and then the dependency chain a request has.
 *    Last block in the chain (can also be the only one) would be the 
 *    concrete BL object /array of objects for this request.
 * 	  Merges filters, dependencies, and BL handlers into a single execution chain
 *    where the order is Filters first, then validator then the bl Chain Links
 *    
 * @author Itay Moav
 * @Date  2017-05-19
 */
abstract class aFilteredValidatedChainLink extends aChainLink{

    /**
     * @var array<\Talis\Chain\Filters\aFilter>
     */
	protected array $filters = [];
	
	/**
	 *                   dependency class name
	 *                                param name
	 *                                        param value         
	 * @var array<int,array<mixed>>
	 */
	protected array $dependencies = [];
	
	/**
	 * builds the chain from the filter+dependencies+bls
	 *  Merges filters, dependencies, and BL handlers into a single execution chain
 	 *  where the order is Filters first, then validator then the bl Chain Links
	 */
	final protected function load_chain_container():void{
	    $this->set_chain_container(new ChainContainer(array_merge($this->filters,$this->dependencies,$this->get_next_bl())));
	}
	
	/**
	 * I am blocking any processing power, the job of this class is ONLY 
	 * to host the filters and dependencies!
	 * 
	 * {@inheritDoc}
	 * @see \Talis\Chain\aChainLink::process()
	 */
	final public function process():aChainLink{
		return $this;	
	}
	
	/**
	 * Return the first BL aChainLink class in the actual 
	 * process.
	 * [   class name,[params]  ],
	 * [   class name,[params]  ]
	 * 
	 * @return  array<array<mixed>>
	 */
	abstract protected function get_next_bl():array;
		
	/**
	 * @param \Talis\Message\Request $Request
	 * @param \Talis\Message\Response $Response
	 * @param array<mixed> $params
	 */
	public function __construct(\Talis\Message\Request $Request,\Talis\Message\Response $Response,array $params=[]){
		parent::__construct($Request,$Response,$params);
		$this->load_chain_container();
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/PayloadToString200.php">
<?php namespace Talis\Chain;

/**
 * This finishes a chain link with the iRenderer to echo a stringified version of the payload.
 * status 200.
 * 
 * @author Itay Moav
 * @date 20202-04-30
 */
class PayloadToString200 extends aChainLink implements \Talis\commons\iRenderable{
    /**
     * No processing, just rendering
     * 
     * {@inheritDoc}
     * @see \Talis\Chain\aChainLink::process()
     */
	public function process():aChainLink{
	    /*
		$this->Response->setMessage('GREAT SUCCESS!');
		$this->Response->setStatus(new \Talis\Message\Status\Code200);
		$this->Response->markResponse();
		*/
		return $this;
	}
	
	/**
	 * 
	 * {@inheritDoc}
	 * @see \Talis\commons\iRenderable::render()
	 */
	public function render(\Talis\commons\iEmitter $emitter):void{
	    $res = $this->Response->getPayload() . '';
	    
	    \Talis\TalisMain::logger()->debug('PAYLOAD RESPONSE STRINGIFIED');
	    \Talis\TalisMain::logger()->debug($res);

	    header('HTTP/1.1 200 Ok');
	    $all_other_headers = $this->Response->getHeaders();
	    if($all_other_headers){
	    
	        \Talis\TalisMain::logger()->debug('SENDING HEADERS');
	        \Talis\TalisMain::logger()->debug($all_other_headers);
	        
	        foreach($all_other_headers as $other_header){
	            header($other_header);
	        }
	    }
	    echo $res;
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/Errors/aError.php">
<?php namespace Talis\Chain\Errors;

/**
 * basic error/problem class
 * 
 * @author Itay Moav
 * @date 2017-05-23
 *
 */
abstract class aError extends \Talis\Chain\aChainLink implements \Talis\commons\iRenderable{
	/**
	 * 
	 * @var integer
	 */
    protected int $http_code	 = 0;
	
    /**
     * 
     * @return string
     */
	abstract protected function format_human_message():string;
	
	/**
	 * This is an end of the line chain link, return itself.
	 * @return \Talis\Chain\aChainLink
	 */
	public function process():\Talis\Chain\aChainLink{
		return $this;
	}
	
	/**
	 *  
	 */
	public function render(\Talis\commons\iEmitter $emitter):void{
	    \Talis\TalisMain::logger()->error($this->params,false);
	    \Talis\TalisMain::logger()->error($this->format_human_message(),true);
				
		$this->Response->setMessage($this->format_human_message());
		$status_class = "\Talis\Message\Status\Code{$this->http_code}";
		$this->Response->setStatus(new $status_class);
		$this->Response->markError();
		$emitter->emit($this->Response);		
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/Errors/ApiNotFound.php">
<?php namespace Talis\Chain\Errors;

/**
 * API class was not found for the input route
 * 
 * @author Itay Moav
 * @date 2017-05-23
 */
class ApiNotFound extends aError{
	protected int $http_code = 404;
	
	/**
	 * {@inheritDoc}
	 * @see \Talis\Chain\Errors\aError::format_human_message()
	 */
	protected function format_human_message():string{
	    $api_uri = $this->Request->getUri();
		return "Api resource for [{$api_uri}] can not be found!";
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/Errors/BLLinkMissingInChain.php">
<?php namespace Talis\Chain\Errors;

/**
 * API class was not found for the input route
 * 
 * @author Itay Moav
 * @date 2017-05-23
 */
class BLLinkMissingInChain extends aError{
	protected int $http_code = 500;
	
	/**
	 * {@inheritDoc}
	 * @see \Talis\Chain\Errors\aError::format_human_message()
	 */
	protected function format_human_message():string{
		$api_uri = $this->Request->getUri();
		return "Missing BL link for URI {$api_uri}. This request chain was not properly configured. The BL Link is missing, probably in the API class.";
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/Errors/README.md">
Errors as opposed to Dependencies are simple Renderable objects.  
They do not validate but they do maintain the chain.  
They emit the Response as error+ error message + original body to the client.  
BEWARE! If you have a chain that might decide in the middle to emit a not auth error to clean the body.  
In general, auth should be calculated in the start
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/Errors/AccessForbbiden.php">
<?php namespace Talis\Chain\Errors;

/**
 * User is not allowed to run this API class
 * 
 * @author Itay Moav
 * @date 2022-07-17
 */
class AccessForbbiden extends aError{
	protected int $http_code = 403;
	
	/**
	 * {@inheritDoc}
	 * @see \Talis\Chain\Errors\aError::format_human_message()
	 */
	protected function format_human_message():string{
		$api_uri = $this->Request->getUri();
		return "Current user is not allowed in {$api_uri}.";
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/Errors/Unauthenticated.php">
<?php namespace Talis\Chain\Errors;

/**
 * Unauthenticated request
 * 
 * @author Itay Moav
 * @date 2022-12-01
 */
class Unauthenticated extends aError{
	protected int $http_code = 401;
	
	/**
	 * {@inheritDoc}
	 * @see \Talis\Chain\Errors\aError::format_human_message()
	 */
	protected function format_human_message():string{
		$api_uri = $this->Request->getUri();
		return "Unauthenticated request for {$api_uri}.";
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/OptionsAllowed.php">
<?php namespace Talis\Chain;

/**
 * Responsebility:
 *  Response for an OPTIONS request
 *  You must specify in a the chain params a string of `allowed` request methods. 
 *  
 * @author Itay Moav
 * @Date  2019-06-06
 */
class OptionsAllowed extends aChainLink implements \Talis\commons\iRenderable{
    
    /**
     * can be GET,POST,OPTIONS,DELETE,FETCH,PATCH etc 
     * @return string "...OPTIONS, DELETE, FETCH..."
     */
    protected function allowed():string{
        return 'OPTIONS';
    }
    
    /**
     * {@inheritDoc}
     * @see \Talis\Chain\aChainLink::process()
     */
    final public function process():aChainLink{
        $this->Response->setHeader('Allow: ' . $this->allowed());
		return $this;
	}
	
	/**
	 * 
	 * {@inheritDoc}
	 * @see \Talis\commons\iRenderable::render()
	 */
	public function render(\Talis\commons\iEmitter $emitter):void{
		\Talis\TalisMain::logger()->debug($this->Request->getUri() . ' FINISHED CHAIN WITH optional SUCCESS');
		$this->Response->setMessage('Allowed Options');
		$this->Response->setStatus(new \Talis\Message\Status\Code204);
		$this->Response->markResponse();
		$emitter->emit($this->Response);
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Chain/PayloadToJson200.php">
<?php namespace Talis\Chain;

/**
 * This finishes a chain link with the iRenderer to echo a stringified version of the payload.
 * status 200.
 * 
 * @author Itay Moav
 * @date 20202-04-30
 */
class PayloadToJson200 extends aChainLink implements \Talis\commons\iRenderable{
	public function process():aChainLink{
	    /*
		$this->Response->setMessage('GREAT SUCCESS!');
		$this->Response->setStatus(new \Talis\Message\Status\Code200);
		$this->Response->markResponse();
		*/
		return $this;
	}
	
	/**
	 * 
	 * {@inheritDoc}
	 * @see \Talis\commons\iRenderable::render()
	 */
	public function render(\Talis\commons\iEmitter $emitter):void{
	    $res = json_encode($this->Response->getPayload());
	    
	    \Talis\TalisMain::logger()->debug('JSON RESPONSE');
	    \Talis\TalisMain::logger()->debug($res);
	    
	    header('HTTP/1.1 200 Ok');
	    header('Content-Type: application/json');
	    $all_other_headers = $this->Response->getHeaders();
	    if($all_other_headers){

	        \Talis\TalisMain::logger()->debug('SENDING HEADERS');
	        \Talis\TalisMain::logger()->debug($all_other_headers);
	        
	        foreach($all_other_headers as $other_header){
	            header($other_header);
	        }
	    }
	    echo $res;
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Doors/Daemon.php">
<?php namespace Talis\Doors;

/**
 * SERVES ActiveMQ originating messages
 * 
 * Main entry point for the request chain
 * Translate the input into the initial request object
 * and moves it along
 * 
 * Will assume a string (base64 encoded):
 * {"url":"[version][action][subaction][type]",      #for example 1/event/repeat/create|update|read|delete
 *  "params": {}
 * }     
 * 
 * 
 * Loads the right controller and action.
 * Renders the $Result of the action
 * Can handle page caching.
 * Error handling
 *  
 */
class Daemon{
	
	/**
	 * Starts the chain reaction. builds request/check dependencies/run main logic
	 */
	public function gogogo(string $raw_request):void{
		
		try{
			//decode
			$decoded_request = json_decode(base64_decode($raw_request));
			\Talis\TalisMain::logger()->debug('MESSAGE RECEIVED');
			\Talis\TalisMain::logger()->debug($decoded_request);
			
			//TalisMain is the first step in the general chain. It is NOT tailored specificly for the http request.
			$request_parts = $this->get_uri($decoded_request->url);
		    (new \Talis\TalisMain)->begin($request_parts,$decoded_request->params,$decoded_request->url)
    		    ->nextLinkInchain()
    		    ->render(new \Talis\Message\Renderers\HTTP);

		}catch(\Throwable $e){ // TODO for now, all errors are TalisMain, better handling later
		    \Talis\TalisMain::logger()->fatal($e,true);
			$response = new \Talis\Message\Response;
			$response->markError();
			$response->setStatus(new \Talis\Message\Status\Code500);
			$response->setMessage($e.'');
			(new \Talis\Message\Renderers\HTTP)->emit($response);
		}
	}
	
	/**
	 * Parses the server input to generate raw uri parts
	 * @return array<string>
	 */
	private function get_uri(string $uri):array{
		return explode('/',$uri);
	}
}

</TalisFramework>

<TalisFramework path="/src/Talis/Doors/HTTP.php">
<?php namespace Talis\Doors;

/**
 * Main entry point for the request chain
 * Translate the input into the initial request object
 * and moves it along
 *
 * Will assume 3 levels [action][subaction][type] for example event/repeat/create|update|read|delete
 *
 * Loads the right controller and action.
 * Renders the $Result of the action
 * Can handle page caching.
 * Error handling
 */
class HTTP
{

    /**
     *
     * @var string $full_uri
     */
    protected string $full_uri;
    /**
     * @var string $root_uri The relative subfolder to the domain. 
     * 
     * If your system door is accessible at example.com/talisroot then the root uri is /talisroot
     */
    protected string $root_uri;

    /**
     * Starts the chain reaction.
     * builds request/check dependencies/run main logic
     *
     * @param string $root_uri
     *            The relative subfolder to the domain. If your system door is accessible at example.com/talisroot then the root uri is /talisroot
     *            if it is just example.com, then it is ''
     */
    public function gogogo(string $root_uri):void
    {
        \Talis\TalisMain::logger()->debug("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nREQUEST LOG STARTS HERE!");
        $this->root_uri = $root_uri;
        dbgn("ROOT URI [{$this->root_uri}]");
        
        try {
            // TalisMain is the first step in the general chain. It is NOT tailored specificly for the http request.
            (new \Talis\TalisMain())->begin($this->get_uri_from_server(), $this->get_request_body(), $this->full_uri)
                ->nextLinkInchain()
                ->render(new \Talis\Message\Renderers\HTTP());
        } catch (\Throwable $e) { // TODO for now, all errors are TalisMain, better handling later
            \Talis\TalisMain::logger()->fatal($e,true);
            $response = new \Talis\Message\Response();
            $response->markError();
            $response->setStatus(new \Talis\Message\Status\Code500());
            if(defined('SHOW_EXCEPTIONS')){
                $response->setMessage($e . '');
                $response->getPayload()->TalisErrorStack = $e->getTrace();
            } else {
                $response->setMessage('An error has occured. Chaos Snakes have been dispatched.');
            }
            
            (new \Talis\Message\Renderers\HTTP())->emit($response);
        }
    }

    /**
     * Parses the server input to generate raw uri parts
     * @return array<string>
     */
    protected function get_uri_from_server(): array
    {
        $this->full_uri = $this->root_uri ? explode($this->root_uri, $_SERVER['REQUEST_URI'])[1] : $_SERVER['REQUEST_URI'];//@phpstan-ignore-line

        // remove ? and after if exists
        $without_question = rtrim(explode('?', $this->full_uri)[0], '/');
        $request_parts = explode('/', $without_question);
        return $request_parts;
    }

    /**
     * Parses the http input stream to get the body and decode into stdClass
     *
     * @return ?\stdClass
     */
    protected function get_request_body(): ?\stdClass
    {
        $json_request_body = file_get_contents('php://input');
        \Talis\TalisMain::logger()->debug('RAW INPUT FROM CLIENT');
        \Talis\TalisMain::logger()->debug($json_request_body);
        return json_decode($json_request_body?:'');
    }
}
</TalisFramework>

<TalisFramework path="/src/Talis/Doors/CliEmbeded.php">
<?php namespace Talis\Doors;

/**
 * Embeded CLI calls in code.
 * Saves on parsing
 * 
 * Not necessarily the Main entry point for the request chain
 * Translate the input into the initial request object
 * and moves it along
 * This is embeded in other codes
 * 
 * Will assume a two parameters sent to the cli door
 * url and stdclass. The stdClass is manufacured in the code that embeds this
 */
class CliEmbeded{

    /**
     * Starts the chain reaction. builds request/check dependencies/run main logic
     * @param string $url
     * @param \stdClass $body
     */
	public function gogogo(string $url,\stdClass $body):void{
		try{
			\Talis\TalisMain::logger()->debug('EMBEDED CLI BODY');
			\Talis\TalisMain::logger()->debug($body);

			//TalisMain is the first step in the general chain. It is NOT tailored specificly for the http request.
			$request_parts = $this->get_uri($url);
			(new \Talis\TalisMain)->begin($request_parts,$body,$url)
							   ->nextLinkInchain()
					           ->render(new \Talis\Message\Renderers\Cli)
			;

		}catch(\Throwable $e){ // TODO for now, all errors are TalisMain, better handling later
		    \Talis\TalisMain::logger()->fatal($e,true);
			$response = new \Talis\Message\Response;
			$response->markError();
			$response->setStatus(new \Talis\Message\Status\Code500);
			$response->setMessage($e.'');
			(new \Talis\Message\Renderers\Cli)->emit($response);
		}
	}

	/**
	 * Parses the server input to generate raw uri parts
	 * @param string $uri
	 * @return array<string>
	 */
	private function get_uri(string $uri):array{
		return explode('/',$uri);
	}
}

</TalisFramework>

<TalisFramework path="/src/Talis/Doors/Cli.php">
<?php namespace Talis\Doors;

/**
 * SERVES cli originating messages
 * 
 * Main entry point for the request chain
 * Translate the input into the initial request object
 * and moves it along
 * 
 * Will assume a two or three parameters sent to the cli door
 * url json_decoded_stdclass 
 * OR
 * url base64_encoded(json_string_encoded(stdclass)) is_base64_encoded
 * 
 * examples:
 * 
 * path/to/lord_commander /test/ping/read "{n:1,l:2}";
 * OR
 * path/to/lord_commander /test/ping/read "{n:1,l:2} yes";
 * 
 * Loads the right controller and action.
 * Renders the $Result of the action
 * Can handle page caching.
 * Error handling
 *  
 */
class Cli{

    /**
     * Starts the chain reaction. builds request/check dependencies/run main logic
     * @param string $url
     * @param ?string $raw_request_body
     * @param bool $is_base64_encoded
     */
	public function gogogo(string $url,?string $raw_request_body,bool $is_base64_encoded=false):void{
	    $raw_request_body = $raw_request_body?:'';
		try{
		    \Talis\TalisMain::logger()->debug('$raw_request_body');
		    \Talis\TalisMain::logger()->debug($raw_request_body);
		    
		    //decode
		    if($is_base64_encoded && $raw_request_body){
		        $raw_request_body = base64_decode($raw_request_body);
		        \Talis\TalisMain::logger()->debug('base64 decoded request_body');
		        \Talis\TalisMain::logger()->debug($raw_request_body);
		    }
		    
		    $decoded_request_body = json_decode($raw_request_body?:'');
		    \Talis\TalisMain::logger()->debug('$decoded_request_body');
		    \Talis\TalisMain::logger()->debug($decoded_request_body);
		    
		    //TalisMain is the first step in the general chain. It is NOT tailored specificly for the http request.
		    $request_parts = $this->get_uri($url);
		    (new \Talis\TalisMain)->begin($request_parts,
		        $decoded_request_body,
		        $url)
		        ->nextLinkInchain()
		        ->render(new \Talis\Message\Renderers\Cli);

		}catch(\Throwable $e){ // TODO for now, all errors are TalisMain, better handling later
		    \Talis\TalisMain::logger()->fatal($e,true);
			$response = new \Talis\Message\Response;
			$response->markError();
			$response->setStatus(new \Talis\Message\Status\Code500);
			$response->setMessage($e.'');
			(new \Talis\Message\Renderers\Cli)->emit($response);
			exit(-1);
		}
	}

	/**
	 * Parses the server input to generate raw uri parts
	 * @param string $uri
	 * @return array<string>
	 */
	private function get_uri(string $uri):array{
		return explode('/',$uri);
	}
}

</TalisFramework>

<TalisFramework path="/src/Talis/Doors/README.md">
Here be the doors, the code that translate each different type 
of possible request (CLI/HTTP/Qmessage and more)
into a unified protocol which is sent to TalisMain, to start the chain.
</TalisFramework>

<TalisFramework path="/src/Talis/Doors/Rest.php">
<?php namespace Talis\Doors;

/**
 * Main entry point for the request chain
 * Translate the input into the initial request object
 * and moves it along
 * 
 * Will assume 2 levels [action][subaction] and [type] is calculated by the http method (post=create, get=read, delete=delete, put=update. for example event/repeat/create|update|read|delete
 * 
 * Loads the right controller and action.
 * Renders the $Result of the action
 * Can handle page caching.
 * Error handling
 *  
 */
class Rest extends HTTP{
	
	/**
	 * Parses the server input to generate raw uri parts
	 * @return array<string>
	 */
	protected function get_uri_from_server():array{
	    $method = '';
	    switch(isset($_SERVER['REQUEST_METHOD']) ? $_SERVER['REQUEST_METHOD'] : 'GET'){
	        case 'POST':
	            $method = 'create';
	            break;
	            
	        case 'PUT':
	            $method = 'update';
	            break;
	            
	        case 'PATCH':
	            $method = 'partialupdate';
	            break;
	        
	        case 'DELETE':
	            $method = 'delete';
	            break;
	            
	        case 'HEAD':
	            $method = 'head';
	            break;
	        
	        case 'OPTIONS':
	            $method = 'options';
	            break;
	        
	        default:
	            $method = 'read';
	            break;
	    }
	    
	    $this->full_uri = $this->root_uri ? explode($this->root_uri,$_SERVER['REQUEST_URI'])[1] : $_SERVER['REQUEST_URI'];//@phpstan-ignore-line
		//remove ? and after if exists
		$without_question = rtrim(explode('?',$this->full_uri)[0],'/');
		$request_parts    = explode('/',$without_question);
		//insert the method as the third part
		array_splice($request_parts,3,0,$method);
		return $request_parts;
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Context.php">
<?php namespace Talis;
/**
 * The context object purpose is to be shared via 
 * and entire process and hold information/resources/settings common to it all.
 * As opposed to Response/Request this is not a Message
 * that can be transfered over to another system (i.e. not serilizable /JSONable).
 * The contex is private to the process.
 * 
 * The context is being held in a static variable in 
 * @author itay
 *
 */
class Context{
    public const NaN = 'NaN';
    
    /**
     * 
     * @var array<mixed> of shared resources in the current process. 
     */
	private array $resources = [];
	
	/**
	 * getter/setter for resources array.
	 * 
	 * @param string $resource_name
	 * @param mixed $resource
	 * @return mixed
	 */
	public function resource(string $resource_name,$resource=null){
	    if($resource){
	        $this->resources[$resource_name] = $resource;
	    }
	    return $this->resources[$resource_name];
	}
		
}
</TalisFramework>

<TalisFramework path="/src/Talis/TalisMain.php">
<?php namespace Talis;

/**
 * MAIN APP ENTRY POINT!
 * 
 * Responsebility: Parses the user input to identify the API class to instantiate
 * This is the ROUTER
 * 
 * @author Itay Moav
 * @Date  2017-05-19
 */
class TalisMain{
    
    /**
     * instantiate this in the app bootstrap
     * @var string
     */
    static public string $APP_PATH;

	/**
	 * Logger used for all Talis lib log calls.
	 * 
	 * @var \Talis\commons\iLogger
	 */
	static private \Talis\commons\iLogger $talis_logger;
    
	/**
	 * @param \Talis\commons\iLogger $logger
	 */
	static public function set_logger(\Talis\commons\iLogger $logger):void{
		self::$talis_logger = $logger;
	}

	/**
	 * @return \Talis\commons\iLogger
	 */
	static public function logger():\Talis\commons\iLogger{
		return self::$talis_logger;
	}

	/**
	 * I am setting this up in the specific apps using Talis. 
	 * I usually would like to use  it to login someone or check generic roles etc
	 * 
	 * @var ?callable a function to run on init.
	 */
    static public $registered_init_func = null;
	
	/**
	 * The name of the router to use to get the API class and GET params.
	 * This is a string of the namespace + classname.
	 * Usually you will put it in the bootstrap file.
	 * 
	 * @var string
	 */
	static public string $registered_router = \Talis\Router\DefaultRouter::class;
	
	/**
	 * Context for this process, which is not part of the Response Request
	 * @var \Talis\Context
	 */
	static public \Talis\Context $Context;
	
	/**
	 * 
	 * @var \Talis\Router\aRouter
	 */
	private \Talis\Router\aRouter $Router;
	
	/**
	 * @var array<mixed>
	 */
	private array $extra_params = [];
	
	/**
	 * Body of the request, json decoded string
	 * @var ?\stdClass
	 */
	private ?\stdClass $req_body;
	
	/**
	 * The head of the BL process chain, usually that would be the API head class built from the route,
	 * but on occassions that would be the error class, in case there where issues
	 * 
	 * @var \Talis\Chain\aChainLink $RequestChainHead
	 */
	private \Talis\Chain\aChainLink $RequestChainHead;

	/**
	 * Holds the request parameters (GET/POST etc)
	 * 
	 * @var \Talis\Message\Request $Request
	 */
	private \Talis\Message\Request $Request;
	
	/**
	 * Main entry point after the Door for a specific protocol is finished (http/rest/stopmp/async etc)
	 * 
	 * @param array<string> $request_parts
	 * @param \stdClass $request_body
	 * @param string $full_uri
	 * @return \Talis\TalisMain
	 */
	public function begin(array $request_parts,?\stdClass $request_body,string $full_uri):\Talis\TalisMain{
		$this->req_body = $request_body;
		self::$Context = new \Talis\Context;
		$Response = new \Talis\Message\Response;
		
		try{
		    $this->Router = new self::$registered_router($request_parts);
		    $this->extra_params = $this->Router->generate_query();
		    $this->build_request($full_uri);
		    $this->Router->generate_route();
		    $this->RequestChainHead = $this->Router->get_chainhead($this->Request,$Response);
			
			//the dynamic init
			if(self::$registered_init_func){
				$func = self::$registered_init_func;
				$func($this->Request);
			}
			
		} catch(\Talis\Exception\BadUri $e){
		    $this->RequestChainHead = new Chain\Errors\ApiNotFound($this->Request,$Response,[$e->getMessage()]);
		}
		return $this;
	}
	
	/**
	 * Init the API class and call it's dependency checks
	 * 
	 * @return \Talis\commons\iRenderable
	 */
	public function nextLinkInchain():\Talis\commons\iRenderable{
		return $this->RequestChainHead->nextLinkInchain();
	}
	
	/**
	 * @param string $full_uri
	 */
	private function build_request(string $full_uri):void{
	    self::logger()->debug('BUILDING REQUEST WITH BODY');
	    self::logger()->debug($this->req_body);
		$this->Request = new \Talis\Message\Request($full_uri,$this->extra_params,$this->req_body);
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Exception/ParamNotFound.php">
<?php namespace Talis\Exception;
/**
 * Could not find the param in the Request
 */
class ParamNotFound extends \Exception{
    /**
     * @param string $param_name
     */
	public function __construct(string $param_name){
		parent::__construct("Param [{$param_name}] not found!");
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Exception/ClassNotFound.php">
<?php namespace Talis\Exception;
/**
 * Could not find class for inclusion
 */
class ClassNotFound extends \Exception{
    /**
     * @param string $file
     */
	public function __construct(string $file){
		parent::__construct("failed to include [{$file}]");
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Exception/FileNotFound.php">
<?php namespace Talis\Exception;
/**
 * Could not find class for inclusion
 */
class FileNotFound extends \Exception{
    /**
     * @param string $file
     */
	public function __construct(string $file){
		parent::__construct("[{$file}] not found!");
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Exception/BadUri.php">
<?php namespace Talis\Exception;
/**
 * Could not find class for inclusion
 */
class BadUri extends \Exception{
    /**
     * 
     * @param string $uri
     */
	public function __construct($uri){
	    parent::__construct("Badboy URI [{$uri}]");
	}
}
</TalisFramework>

<TalisFramework path="/src/Talis/Router/aRouter.php">
<?php namespace Talis\Router;

/**
 * Define the router methods
 * 
 * @author itay
 * @date 2019-07-16
 */
abstract class aRouter{
    /**
     * Original request parts broken down by the respective doors of this request
     * @var array<string>
     */
    protected array $request_parts;
    
    /**
     * Holds data about the initial API class, path and class name, usually
     * 
     * @var array<string, string>
     */
    protected array $route;
    
    /**
     * @param array<string> $request_parts
     */
    public function __construct(array $request_parts){
        \Talis\TalisMain::logger()->debug('request_parts');
        \Talis\TalisMain::logger()->debug($request_parts);
        $this->request_parts = $request_parts;
    }
    
    /**
     * Generates the API class name. This will be the name
     * of the class to start the chain, business wise
     *
     * ASSUMES CONVENTION OF 3 LEVELS URL [action][subaction][type]
     *
     * array [route=>the path to the class, classname=>the name of the class]
     */
    abstract public function generate_route():void;
    
    /**
     * Return would be GET params from butified urls
     * @return array<string>
     */
    abstract public function generate_query():array;
    
    /**
     * Instantiate the first step in the chain, The API class that we got from the route.
     * Or, an error response, if API does not exist
     *
     * @throws \Talis\Exception\BadUri
     * @return \Talis\Chain\aFilteredValidatedChainLink
     */
    abstract public function get_chainhead(\Talis\Message\Request $Request, \Talis\Message\Response $Response):\Talis\Chain\aChainLink;
    
}
</TalisFramework>

<TalisFramework path="/src/Talis/Router/DefaultRouter.php">
<?php namespace Talis\Router;

/**
 * @author itay
 */
class DefaultRouter extends aRouter{
    /**
     * Generates the API class name. This will be the name
     * of the class to start the chain, business wise
     *
     * ASSUMES CONVENTION OF 3 LEVELS URL [action][subaction][type]
     *
     * array [route=>the path to the class, classname=>the name of the class]
     */
    public function generate_route():void{
        if(count($this->request_parts) < 4){ //one root path + three parts to define the API 
            throw new \Talis\Exception\BadUri(print_r($this->request_parts,true));
        }
        
        $this->route= [
            'route'      => \Talis\TalisMain::$APP_PATH . "/api/{$this->request_parts[1]}/{$this->request_parts[2]}/{$this->request_parts[3]}.php",
            'classname'  => "\Api\\{$this->request_parts[1]}{$this->request_parts[2]}{$this->request_parts[3]}"
        ];
        \Talis\TalisMain::logger()->debug("Doing route [{$this->route['route']}]");
    }
    
    /**
     * Return would be GET params from butified urls
     * @return array<string>
     */
    public function generate_query():array{
        $c = count($this->request_parts);
        $extra_params = [];
        for($i=4; $i<$c;$i+=2){
            $extra_params[$this->request_parts[$i]] = ($this->request_parts[$i+1]??'');
        }

        if(count($_GET)>0){
            $extra_params = array_merge($extra_params,$_GET);
            \Talis\TalisMain::logger()->debug('extra with HTTP GET params');
            \Talis\TalisMain::logger()->debug($extra_params);
        }
        return $extra_params;
    }

    /**
     * Instantiate the first step in the chain, The API class that we got from the route.
     * Or, an error response, if API does not exist
     *
     * @throws \Talis\Exception\BadUri
     * {@inheritDoc}
     * @see \Talis\Router\aRouter::get_chainhead()
     */
    public function get_chainhead(\Talis\Message\Request $Request, \Talis\Message\Response $Response): \Talis\Chain\aChainLink
    {
        $full_path_route = $this->route['route'];
        \Talis\TalisMain::logger()->debug("TRYING TO INCLUDE: {$full_path_route}");
        if(file_exists($full_path_route)){
            require_once $full_path_route;
        } else {            
            throw new \Talis\Exception\BadUri($full_path_route);
        }
        return new $this->route['classname']($Request, $Response);
    }
}
</TalisFramework>

